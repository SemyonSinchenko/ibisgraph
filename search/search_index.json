{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"IbisGraph","text":"<p>An iplementation of Pregel-framework for Graph Processing on top of Ibis-project DataFrames. Batteries are included!</p> <p></p>"},{"location":"#table-on-contents","title":"Table on contents","text":"<ul> <li>Documentation:<ul> <li>Quick start</li> <li>Comparison of IbisGraph with oither tools</li> <li>About the Pregel framework</li> </ul> </li> <li>Usecases:<ul> <li>Jaccard Index for Business Entity Resolution</li> <li>Shortest Paths for Compliance</li> <li>PageRank for Financial Networks Analysis</li> </ul> </li> <li>API Docs (auto-generated)</li> </ul>"},{"location":"concepts/","title":"Concepts","text":"<ul> <li>About the Pregel framework</li> <li>Comparison of IbisGraph with other tools</li> </ul>"},{"location":"ibisgraph_versus_others/","title":"IbisGraph vs Other Graph Processing Solutions","text":""},{"location":"ibisgraph_versus_others/#overview","title":"Overview","text":"<p>This document provides an honest comparison between IbisGraph and other graph processing solutions. The goal is to help you understand when IbisGraph might be appropriate for your use case, and more importantly, when it might not be the best choice.</p>"},{"location":"ibisgraph_versus_others/#core-differences-in-approach","title":"Core Differences in Approach","text":"<p>IbisGraph takes a unique approach by translating Pregel-style graph algorithms into SQL operations that run directly in your data warehouse or lake. This is fundamentally different from:</p> <ul> <li>In-memory graph libraries (NetworkX, igraph): Process graphs entirely in memory on a single machine</li> <li>Specialized graph databases (Neo4j, TigerGraph): Store and process data in specialized graph-native formats</li> </ul>"},{"location":"ibisgraph_versus_others/#performance-characteristics","title":"Performance Characteristics","text":""},{"location":"ibisgraph_versus_others/#single-node-performance","title":"Single-Node Performance","text":"<p>Let's be clear: IbisGraph will be slower than specialized solutions for most operations:</p> <pre><code>Operation        | NetworkX/igraph | Neo4j    | IbisGraph\n-----------------|----------------|----------|----------\nPageRank         | Very Fast      | Fast     | Slow\nPath Finding    | Very Fast      | Fast     | Slow\nCommunity Det.   | Very Fast      | Fast     | Slow\n</code></pre> <p>This performance gap exists by design because: 1. IbisGraph translates graph operations into SQL, adding overhead 2. Data warehouse engines are optimized for different workloads 3. The Pregel model requires multiple iterations with SQL operations each time</p>"},{"location":"ibisgraph_versus_others/#scaling-characteristics","title":"Scaling Characteristics","text":"<p>However, the picture changes with scale:</p> <pre><code>Data Size  | NetworkX/igraph | Neo4j      | IbisGraph\n-----------|----------------|------------|------------\nSmall      | Excellent     | Very Good  | Poor\nMedium     | Poor*         | Good       | Good\nLarge      | Fails*        | Varies**   | Good\nVery Large | Fails*        | Varies**    | Works***\n</code></pre> <p>* Requires loading entire graph into memory ** Depends on Neo4j cluster size/configuration *** Limited by underlying data warehouse capabilities</p>"},{"location":"ibisgraph_versus_others/#when-to-use-ibisgraph","title":"When to Use IbisGraph","text":""},{"location":"ibisgraph_versus_others/#good-use-cases","title":"Good Use Cases","text":"<ol> <li> <p>Data Already in a Warehouse</p> <ul> <li>You have graph-structured data in Snowflake, BigQuery, etc.</li> <li>Data volume makes extraction impractical</li> <li>Security policies prevent data movement</li> </ul> </li> <li> <p>Analytical Workflows</p> <ul> <li>Graph analysis is part of a larger analytical pipeline</li> <li>Results feed into other SQL-based processing</li> <li>Regular batch processing of graph algorithms</li> </ul> </li> <li> <p>Resource Constraints</p> <ul> <li>Cannot justify dedicated graph database infrastructure</li> <li>Need to leverage existing data warehouse investment</li> <li>Data size exceeds single-machine memory</li> </ul> </li> </ol>"},{"location":"ibisgraph_versus_others/#poor-use-cases","title":"Poor Use Cases","text":"<ol> <li> <p>Performance-Critical Operations</p> <ul> <li>Real-time graph queries needed</li> <li>Path finding in user-facing applications</li> <li>Interactive graph exploration</li> </ul> </li> <li> <p>Small Graphs</p> <ul> <li>Graphs that easily fit in memory</li> <li>One-off analyses</li> <li>Development/prototyping work</li> </ul> </li> <li> <p>Graph-Native Operations</p> <ul> <li>Heavy use of graph-specific optimizations</li> <li>Complex traversal patterns</li> <li>Graph-native algorithms</li> </ul> </li> </ol>"},{"location":"ibisgraph_versus_others/#specific-comparisons","title":"Specific Comparisons","text":""},{"location":"ibisgraph_versus_others/#vs-networkxigraph","title":"vs NetworkX/igraph","text":""},{"location":"ibisgraph_versus_others/#networkxigraph-advantages","title":"NetworkX/igraph Advantages","text":"<ul> <li>Much faster execution on small-medium graphs</li> <li>Rich ecosystem of algorithms</li> <li>More intuitive API for graph operations</li> <li>Great for research and prototyping</li> <li>Extensive visualization capabilities</li> </ul>"},{"location":"ibisgraph_versus_others/#ibisgraph-advantages","title":"IbisGraph Advantages","text":"<ul> <li>No memory limitations from source data warehouse</li> <li>No need to move data out of warehouse</li> <li>Integrates with existing data pipelines</li> <li>Scales with warehouse resources</li> <li>Maintains data governance/security</li> </ul>"},{"location":"ibisgraph_versus_others/#vs-neo4jtigergraph","title":"vs Neo4j/TigerGraph","text":""},{"location":"ibisgraph_versus_others/#neo4jtigergraph-advantages","title":"Neo4j/TigerGraph Advantages","text":"<ul> <li>Optimized graph storage format</li> <li>Native graph processing engines</li> <li>Rich query languages (Cypher, GSQL)</li> <li>Better for OLTP graph workloads</li> <li>Superior path-finding performance</li> </ul>"},{"location":"ibisgraph_versus_others/#ibisgraph-advantages_1","title":"IbisGraph Advantages","text":"<ul> <li>No separate infrastructure required</li> <li>Uses existing data warehouse skills (SQL)</li> <li>No ETL to separate graph store</li> <li>Automatic scaling with warehouse</li> <li>Lower total cost of ownership</li> </ul>"},{"location":"ibisgraph_versus_others/#implementation-comparison","title":"Implementation Comparison","text":"<pre><code>Aspect          | NetworkX | Neo4j  | IbisGraph\n----------------|----------|--------|----------\nStorage         | RAM      | Native | SQL Tables\nQuery Language  | Python   | Cypher | SQL/Ibis\nScale Limit     | RAM      | Disk   | Warehouse\nLearning Curve  | Low      | Medium | Low*\nSetup Effort    | Minimal  | High   | None**\n</code></pre> <p>* If already familiar with SQL/Ibis ** Assuming data warehouse exists</p>"},{"location":"ibisgraph_versus_others/#real-world-considerations","title":"Real-World Considerations","text":""},{"location":"ibisgraph_versus_others/#data-movement","title":"Data Movement","text":"<p>Moving data out of a warehouse into specialized tools often brings challenges:</p> <ol> <li> <p>Security &amp; Compliance</p> <ul> <li>Data governance policies</li> <li>Audit requirements</li> <li>Access controls</li> </ul> </li> <li> <p>Infrastructure</p> <ul> <li>Network bandwidth</li> <li>Additional storage</li> <li>New system maintenance</li> </ul> </li> <li> <p>Time &amp; Resources</p> <ul> <li>ETL development</li> <li>System setup/maintenance</li> <li>Training requirements</li> </ul> </li> </ol> <p>IbisGraph sidesteps these issues by processing data in place.</p>"},{"location":"ibisgraph_versus_others/#cost-considerations","title":"Cost Considerations","text":"<p>While IbisGraph's performance characteristics might seem inferior, consider the total cost:</p> <pre><code>Cost Factor          | NetworkX | Neo4j    | IbisGraph\n--------------------|----------|----------|------------\nInfrastructure      | Low      | High     | Existing\nMaintenance         | Low      | High     | Existing\nTraining            | Low      | High     | Low\nData Movement       | High     | High     | None\nPerformance Cost    | Low      | Low      | High*\n</code></pre> <p>* In terms of compute resources used per operation</p>"},{"location":"ibisgraph_versus_others/#conclusion","title":"Conclusion","text":"<p>IbisGraph is not trying to compete with NetworkX/igraph for small graph processing or Neo4j for graph-native operations. Instead, it fills a specific niche:</p> <p>Best For:</p> <ul> <li>Processing graph data already in data warehouses</li> <li>When data movement is impractical or prohibited</li> <li>When existing SQL infrastructure must be leveraged</li> <li>When graph operations are part of larger data pipelines</li> </ul> <p>Avoid When:</p> <ul> <li>Performance is critical</li> <li>Graphs easily fit in memory</li> <li>Specialized graph operations are needed</li> <li>Setting up a proper graph database is feasible</li> </ul> <p>The key is understanding these trade-offs and choosing the right tool for your specific needs. IbisGraph's value proposition isn't better performance or more features - it's the ability to perform graph operations where your data already lives.</p>"},{"location":"pagerank/","title":"Using PageRank for Financial Network Analysis","text":""},{"location":"pagerank/#business-case-identifying-key-financial-entities","title":"Business Case: Identifying Key Financial Entities","text":"<p>In financial networks, not all entities are equally important. Some play central roles in moving money, influencing other entities, or connecting different parts of the network. PageRank can help identify these crucial entities by analyzing: - Transaction patterns - Money flow dynamics - Network influence - Systemic importance</p> <p>Originally developed by Google for ranking web pages, PageRank has valuable applications in financial analysis because it can reveal entities that are: - Central to money movement networks - Potential systemic risk sources - Key players in financial markets - Important intermediaries in transaction chains</p>"},{"location":"pagerank/#implementation-with-ibisgraph","title":"Implementation with IbisGraph","text":"<p>Here's how to implement PageRank analysis using IbisGraph while keeping all processing within your data warehouse:</p> <pre><code>import ibis\nimport ibisgraph as ig\n\n# Connect to your data warehouse (e.g., PostgreSQL, Snowflake, etc.)\nconn = ibis.postgres.connect(\n    host='your_host',\n    database='your_db',\n    user='your_user',\n    password='your_password'\n)\n\n# Assume we have a transactions table with columns:\n# - from_account: source account\n# - to_account: destination account\n# - amount: transaction amount\n# - date: transaction date\n\n# Load transaction data\ntransactions = conn.table('transactions')\n\n# Create a weighted graph based on transaction amounts\ngraph = ig.Graph(\n    transactions,\n    source_col='from_account',\n    target_col='to_account',\n    weight_col='amount'  # Weight edges by transaction amounts\n)\n\n# Calculate PageRank scores\npagerank_scores = ig.centrality.page_rank(\n    graph,\n    alpha=0.85,  # Standard damping factor\n    max_iters=100,  # Maximum iterations\n    tol=1e-6  # Convergence tolerance\n)\n\n# Join with account information for analysis\naccount_info = conn.table('account_info')\nranked_accounts = (\n    pagerank_scores\n    .join(\n        account_info,\n        pagerank_scores.node_id == account_info.account_id\n    )\n    .select([\n        'account_id',\n        'account_type',\n        'business_name',\n        'pagerank',\n        account_info.total_volume,  # Assuming this exists\n    ])\n    .order_by(ibis.desc('pagerank'))\n)\n</code></pre>"},{"location":"pagerank/#advanced-analysis-techniques","title":"Advanced Analysis Techniques","text":""},{"location":"pagerank/#time-window-analysis","title":"Time-Window Analysis","text":"<p>Track changes in entity importance over time:</p> <pre><code># Function to create graph for a specific time window\ndef get_time_window_pagerank(start_date, end_date):\n    window_transactions = transactions.filter(\n        (transactions.date &gt;= start_date) &amp;\n        (transactions.date &lt; end_date)\n    )\n\n    window_graph = ig.Graph(\n        window_transactions,\n        source_col='from_account',\n        target_col='to_account',\n        weight_col='amount'\n    )\n\n    return ig.centrality.page_rank(window_graph)\n\n# Compare monthly PageRank scores\ncurrent_month = get_time_window_pagerank('2024-03-01', '2024-04-01')\nprevious_month = get_time_window_pagerank('2024-02-01', '2024-03-01')\n\n# Analyze changes\nrank_changes = (\n    current_month\n    .join(\n        previous_month,\n        current_month.node_id == previous_month.node_id\n    )\n    .select([\n        'node_id',\n        current_month.pagerank.name('current_rank'),\n        previous_month.pagerank.name('previous_rank'),\n        (current_month.pagerank - previous_month.pagerank).name('rank_change')\n    ])\n    .order_by(ibis.desc('rank_change'))\n)\n</code></pre>"},{"location":"pagerank/#risk-weighted-pagerank","title":"Risk-Weighted PageRank","text":"<p>Incorporate risk factors into the analysis:</p> <pre><code># Assume we have risk scores for transactions\nrisk_weighted_txns = transactions.mutate(\n    risk_weight=transactions.amount * transactions.risk_score\n)\n\n# Create risk-weighted graph\nrisk_graph = ig.Graph(\n    risk_weighted_txns,\n    source_col='from_account',\n    target_col='to_account',\n    weight_col='risk_weight'\n)\n\n# Calculate risk-weighted PageRank\nrisk_pagerank = ig.centrality.page_rank(risk_graph)\n</code></pre>"},{"location":"pagerank/#applications-in-financial-analysis","title":"Applications in Financial Analysis","text":""},{"location":"pagerank/#1-systemic-risk-assessment","title":"1. Systemic Risk Assessment","text":"<pre><code># Identify systemically important entities\nsystemic_entities = (\n    pagerank_scores\n    .filter(pagerank_scores.pagerank &gt; pagerank_scores.pagerank.mean() + 2 * pagerank_scores.pagerank.std())\n    .join(account_info, 'node_id')\n    .select([\n        'node_id',\n        'business_name',\n        'account_type',\n        'pagerank',\n        'total_volume'\n    ])\n)\n</code></pre>"},{"location":"pagerank/#2-money-laundering-detection","title":"2. Money Laundering Detection","text":"<pre><code># Combine PageRank with transaction patterns\nsuspicious_entities = (\n    pagerank_scores\n    .join(\n        transactions.group_by('from_account')\n        .aggregate([\n            transactions.amount.count().name('tx_count'),\n            transactions.amount.mean().name('avg_amount')\n        ]),\n        pagerank_scores.node_id == transactions.from_account\n    )\n    .filter(\n        (pagerank_scores.pagerank &gt; 0.01) &amp;  # High influence\n        (transactions.tx_count &gt; 1000) &amp;      # High activity\n        (transactions.avg_amount &lt; 1000)      # Small transactions\n    )\n)\n</code></pre>"},{"location":"pagerank/#3-market-influence-analysis","title":"3. Market Influence Analysis","text":"<pre><code># Analyze market maker influence\nmarket_makers = (\n    pagerank_scores\n    .join(account_info, 'node_id')\n    .filter(account_info.account_type == 'MARKET_MAKER')\n    .select([\n        'node_id',\n        'business_name',\n        'pagerank',\n        account_info.daily_volume,\n        account_info.num_counterparties\n    ])\n    .order_by(ibis.desc('pagerank'))\n)\n</code></pre>"},{"location":"pagerank/#benefits-of-using-ibisgraph-for-pagerank-analysis","title":"Benefits of Using IbisGraph for PageRank Analysis","text":"<ol> <li> <p>Scalability</p> <ul> <li>Processes large transaction networks efficiently</li> <li>Handles millions of transactions and entities</li> <li>Leverages data warehouse computational resources</li> </ul> </li> <li> <p>Data Security</p> <ul> <li>Keeps sensitive financial data within your secure environment</li> <li>Maintains regulatory compliance</li> <li>Provides audit trail for analyses</li> </ul> </li> <li> <p>Real-time Analysis</p> <ul> <li>Can be updated as new transactions occur</li> <li>Supports continuous monitoring</li> <li>Enables quick response to changes in network dynamics</li> </ul> </li> <li> <p>Integration Capabilities</p> <ul> <li>Works with existing data warehouse infrastructure</li> <li>Combines easily with other analysis tools</li> <li>Supports multiple data sources</li> </ul> </li> </ol>"},{"location":"pagerank/#practical-use-cases","title":"Practical Use Cases","text":"<ol> <li> <p>Regulatory Compliance</p> <ul> <li>Identify systematically important financial institutions</li> <li>Monitor market concentration</li> <li>Track changes in financial network structure</li> </ul> </li> <li> <p>Risk Management</p> <ul> <li>Assess counterparty exposure</li> <li>Monitor network dependencies</li> <li>Identify potential cascading failures</li> </ul> </li> <li> <p>Business Intelligence</p> <ul> <li>Find key market participants</li> <li>Analyze customer importance</li> <li>Track market influence</li> </ul> </li> <li> <p>Fraud Detection</p> <ul> <li>Identify unusual influence patterns</li> <li>Detect hidden relationships</li> <li>Monitor network anomalies</li> </ul> </li> </ol> <p>This approach provides a powerful tool for understanding complex financial networks while maintaining data security and leveraging existing infrastructure. It can be integrated into various analysis workflows and supports both strategic and operational decision-making.</p>"},{"location":"pregel/","title":"Pregel Implementation in IbisGraph","text":""},{"location":"pregel/#overview","title":"Overview","text":"<p>This document explains how IbisGraph implements Pregel-like graph processing using SQL operations. The implementation translates Pregel's vertex-centric computation model into a series of SQL operations that can run in any data warehouse or data lake supported by Ibis.</p>"},{"location":"pregel/#what-is-pregel","title":"What is Pregel?","text":"<p>Pregel is a system for large-scale graph processing introduced by Google. It uses a vertex-centric approach where:</p> <ol> <li>Each vertex can store state</li> <li>Vertices communicate through messages</li> <li>Computation proceeds in synchronized iterations (supersteps)</li> </ol> <p>In each superstep:</p> <ol> <li>Vertices receive messages from the previous superstep</li> <li>Update their state based on received messages</li> <li>Send messages to other vertices for the next superstep</li> </ol>"},{"location":"pregel/#sql-translation","title":"SQL Translation","text":"<p>IbisGraph translates this model into SQL operations. Here's a visualization of how a typical superstep works:</p> <pre><code>Initial State:\nTable: vertices\n+----+-------+\n| id | value |\n+----+-------+\n| 1  | 0.2   |\n| 2  | 0.3   |\n| 3  | 0.5   |\n+----+-------+\n\nTable: edges\n+------+--------+\n| from | to     |\n+------+--------+\n| 1    | 2      |\n| 2    | 3      |\n| 3    | 1      |\n+------+--------+\n\nSuperstep:\n1. Generate messages:\n   SELECT \n     e.to as target,\n     v.value as message\n   FROM vertices v\n   JOIN edges e ON v.id = e.from\n\n2. Aggregate messages:\n   SELECT\n     target,\n     SUM(message) as agg_message\n   FROM messages\n   GROUP BY target\n\n3. Update vertices:\n   SELECT\n     v.id,\n     CASE \n       WHEN m.agg_message IS NULL THEN v.value\n       ELSE function(v.value, m.agg_message)\n     END as new_value\n   FROM vertices v\n   LEFT JOIN messages m ON v.id = m.target\n</code></pre>"},{"location":"pregel/#key-components","title":"Key Components","text":""},{"location":"pregel/#1-graph-state","title":"1. Graph State","text":"<ul> <li>Vertex data stored in regular SQL tables</li> <li>Edge data stored in source-target format</li> <li>Additional columns can store vertex/edge attributes</li> </ul>"},{"location":"pregel/#2-message-passing","title":"2. Message Passing","text":"<p>Implemented through: 1. JOIN operations between vertex and edge tables 2. Message generation expressions 3. GROUP BY for message aggregation</p>"},{"location":"pregel/#3-vertex-state-updates","title":"3. Vertex State Updates","text":"<p>Performed using: 1. LEFT JOIN to preserve vertices that receive no messages 2. UPDATE expressions defined by the algorithm 3. Optional active vertex tracking</p>"},{"location":"pregel/#4-halting-conditions","title":"4. Halting Conditions","text":"<p>Multiple stopping criteria available: - Maximum iterations reached - No messages generated - All vertices vote to halt - Custom convergence conditions</p>"},{"location":"pregel/#performance-considerations","title":"Performance Considerations","text":""},{"location":"pregel/#advantages","title":"Advantages","text":"<ol> <li> <p>No Data Movement</p> <ul> <li>All processing happens in the data warehouse</li> <li>No need to extract data or maintain separate systems</li> </ul> </li> <li> <p>Scalability</p> <ul> <li>Inherits data warehouse scaling capabilities</li> <li>No single-machine memory limitations</li> </ul> </li> <li> <p>Integration</p> <ul> <li>Natural integration with SQL-based data pipelines</li> <li>Can leverage existing warehouse optimizations</li> </ul> </li> </ol>"},{"location":"pregel/#limitations","title":"Limitations","text":"<ol> <li> <p>Iteration Overhead</p> <ul> <li>Each superstep requires multiple SQL operations</li> <li>More expensive than native graph processing</li> </ul> </li> <li> <p>Message Handling</p> <ul> <li>Message generation can create large intermediate results</li> <li>Aggregation performance depends on warehouse capabilities</li> </ul> </li> <li> <p>State Management</p> <ul> <li>Vertex state changes require table updates</li> <li>May need careful tuning of checkpoint intervals</li> </ul> </li> </ol>"},{"location":"pregel/#implementation-details","title":"Implementation Details","text":""},{"location":"pregel/#active-vertex-tracking","title":"Active Vertex Tracking","text":"<pre><code># Example of active vertex tracking\npregel.set_has_active_flag(True)\n      .set_initial_active_flag(initial_condition)\n      .set_active_flag_upd_col(update_condition)\n</code></pre>"},{"location":"pregel/#message-generation","title":"Message Generation","text":"<pre><code># Example of message generation\npregel.add_message_to_dst(\n    ibis.case()\n        .when(condition, message_value)\n        .else_(None)\n)\n</code></pre>"},{"location":"pregel/#vertex-updates","title":"Vertex Updates","text":"<pre><code># Example of vertex state update\npregel.add_vertex_col(\n    \"value\",\n    initial_expr=initial_value,\n    update_expr=update_function(old_value, message)\n)\n</code></pre>"},{"location":"pregel/#optimization-tips","title":"Optimization Tips","text":"<ol> <li>Checkpoint Intervals</li> <li>For single-node backends (DuckDB, SQLite):      <pre><code>pregel.set_checkpoint_interval(1)\n</code></pre></li> <li> <p>For distributed engines (Spark, Snowflake):      <pre><code>pregel.set_checkpoint_interval(5)  # or higher\n</code></pre></p> </li> <li> <p>Message Filtering <pre><code># Filter messages from inactive vertices\npregel.set_filter_messages_from_non_active(True)\n</code></pre></p> </li> <li> <p>Early Stopping <pre><code># Stop when no new messages or all vertices inactive\npregel.set_early_stopping(True)\npregel.set_stop_if_all_unactive(True)\n</code></pre></p> </li> </ol>"},{"location":"pregel/#example-pagerank-implementation","title":"Example: PageRank Implementation","text":"<p>Here's how PageRank is implemented using this Pregel framework:</p> <pre><code>def page_rank(graph: IbisGraph, alpha: float = 0.85) -&gt; ibis.Table:\n    n_nodes = graph.num_nodes\n    initial_rank = 1.0 / n_nodes\n\n    pregel = (\n        Pregel(graph)\n        .add_vertex_col(\n            \"rank\",\n            initial_expr=initial_rank,\n            update_expr=alpha * pregel.pregel_msg() + (1 - alpha) / n_nodes\n        )\n        .add_message_to_dst(\n            pregel.pregel_src(\"rank\") / pregel.pregel_src(\"out_degree\")\n        )\n        .set_agg_expression_func(lambda msg: msg.sum())\n    )\n\n    return pregel.run()\n</code></pre> <p>This implementation shows how Pregel concepts map to SQL operations while maintaining the algorithm's logical structure.</p>"},{"location":"pregel/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Message Volume</p> <ul> <li>Filter unnecessary messages when possible</li> <li>Use appropriate aggregation functions</li> <li>Consider using active vertex tracking</li> </ul> </li> <li> <p>State Management</p> <ul> <li>Keep vertex state minimal</li> <li>Use appropriate data types</li> <li>Consider compression for large state</li> </ul> </li> <li> <p>Performance Tuning</p> <ul> <li>Adjust checkpoint intervals based on backend</li> <li>Use appropriate convergence conditions</li> <li>Monitor intermediate result sizes</li> </ul> </li> </ol>"},{"location":"pregel/#debugging-tips","title":"Debugging Tips","text":"<ol> <li> <p>Message Generation</p> <ul> <li>Use <code>pregel_src()</code> and <code>pregel_dst()</code> helpers</li> <li>Check for NULL values in messages</li> <li>Verify message targeting</li> </ul> </li> <li> <p>State Updates</p> <ul> <li>Validate initial state expressions</li> <li>Check update logic with edge cases</li> <li>Monitor convergence patterns</li> </ul> </li> <li> <p>Performance Issues</p> <ul> <li>Check execution plans</li> <li>Monitor intermediate result sizes</li> <li>Verify checkpoint interval settings</li> </ul> </li> </ol>"},{"location":"quick_start/","title":"Quick Start Guide","text":"<p>IbisGraph is a graph analytics library built on top of Ibis, allowing you to perform graph operations on data stored in various backends supported by Ibis. The main benefit of the IbisGraph is that data is staying in the backend and all the operations are done in this backend.</p>"},{"location":"quick_start/#installation","title":"Installation","text":"<p>Install IbisGraph using pip:</p> <pre><code>pip install ibisgraph\n</code></pre>"},{"location":"quick_start/#backend-configuration","title":"Backend Configuration","text":"<p>IbisGraph works with any backend supported by Ibis. You'll need to configure your backend according to the Ibis documentation. Here are a few common examples:</p> <pre><code># DuckDB example\nimport ibis\nconn = ibis.duckdb.connect()\n\n# SQLite example\nconn = ibis.sqlite.connect('path/to/database.db')\n\n# PostgreSQL example\nconn = ibis.postgres.connect(\n    host='localhost',\n    port=5432,\n    user='your_user',\n    password='your_password',\n    database='your_database'\n)\n</code></pre>"},{"location":"quick_start/#basic-usage","title":"Basic Usage","text":"<p>Here's how to get started with IbisGraph:</p> <pre><code>import ibis\nimport ibisgraph as ig\n\n# Connect to your database\nconn = ibis.duckdb.connect()\n\n# Create example edge table\nedges = conn.create_table(\n    'edges',\n    schema={\n        'source': 'int64',\n        'target': 'int64',\n        'weight': 'float64'\n    }\n)\n\n# Create a graph from the edges table\ngraph = ig.Graph(edges, source_col='source', target_col='target', weight_col='weight')\n\n# Calculate degree metrics\ndegrees = graph.degrees()\n\n# Find shortest paths\npaths = graph.shortest_paths(sources=[1, 2, 3])\n\n# Calculate PageRank\npagerank = graph.pagerank()\n</code></pre>"},{"location":"quick_start/#common-operations","title":"Common Operations","text":"<p>Here are some common graph operations you can perform:</p> <pre><code># Get node degrees\nin_degrees = graph.in_degrees()\nout_degrees = graph.out_degrees()\ntotal_degrees = graph.degrees()\n\n# Find similar nodes\nsimilar_nodes = graph.node_similarity(method='jaccard')\n\n# Run community detection\ncommunities = graph.label_propagation()\n</code></pre> <p>For more detailed examples and API reference, please refer to the full documentation.</p>"},{"location":"shortestpaths/","title":"Using Shortest Paths for Risk Assessment and Compliance","text":""},{"location":"shortestpaths/#business-case-transaction-network-risk-analysis","title":"Business Case: Transaction Network Risk Analysis","text":"<p>Financial institutions need to assess the risk of new customers by understanding their potential connections to known high-risk entities. In a transaction network: - Nodes represent entities (individuals or businesses) - Edges represent transactions or other relationships - Some nodes are flagged as high-risk (blacklisted)</p> <p>The key insight is that entities closer to high-risk nodes in the transaction network may pose greater risk themselves.</p>"},{"location":"shortestpaths/#why-shortest-paths-matter","title":"Why Shortest Paths Matter","text":"<p>The shortest path between two entities in a transaction network represents: - The minimum number of intermediaries needed to connect them - The most direct potential influence or relationship path - A quantifiable measure of \"relationship distance\"</p> <p>This analysis helps: - Score new customers based on proximity to high-risk entities - Identify potential money laundering routes - Assess indirect exposure to sanctioned entities - Support Know Your Customer (KYC) processes</p>"},{"location":"shortestpaths/#implementation-with-ibisgraph-in-snowflake","title":"Implementation with IbisGraph in Snowflake","text":"<p>Here's how to implement this analysis using IbisGraph while keeping all processing within Snowflake:</p> <pre><code>import ibis\nimport ibisgraph as ig\n\n# Connect to Snowflake\nconn = ibis.snowflake.connect(\n    user='YOUR_USER',\n    password='YOUR_PASSWORD',\n    account='YOUR_ACCOUNT',\n    database='YOUR_DATABASE',\n    schema='YOUR_SCHEMA'\n)\n\n# Assume we have these tables in Snowflake:\n# - TRANSACTIONS: Historical transaction data\n# - BLACKLIST: Known high-risk entities\n# - NEW_CUSTOMERS: Customers requiring risk assessment\n\n# Load required tables\ntransactions = conn.table('TRANSACTIONS')\nblacklist = conn.table('BLACKLIST')\nnew_customers = conn.table('NEW_CUSTOMERS')\n\n# Create a graph from transactions\ngraph = ig.Graph(\n    transactions,\n    source_col='from_entity',\n    target_col='to_entity',\n)\n\n# Get list of blacklisted entity IDs\nblacklisted_ids = blacklist.select('entity_id').execute().entity_id.tolist()\n\n# Calculate shortest paths from all blacklisted nodes;\n#\n# ShortestPaths routine returns a Map&lt;landmark -&gt; distance&gt;\n# but in this case we need only distances\npaths = (\n    ig.traversal.shortest_paths(graph, landmarks=blacklisted_ids)\n    .select(\n        ibis._[\"node_id\"],\n        ibid._[\"distances\"].values().name(\"distances\"),\n    )\n)\n\n# Create risk scores based on distances\nrisk_assessment = (\n    paths.select([\n        paths.node_id,\n        # Calculate minimum distance to any blacklisted entity\n        paths.distances.min().name('min_distance_to_blacklist'),\n        # Calculate average distance to blacklisted entities\n        paths.distances.mean().name('avg_distance_to_blacklist'),\n        # Count how many blacklisted entities are within 2 steps\n        paths.distances.filter(lambda x: x &lt;= 2).count().name('close_blacklist_count')\n    ])\n)\n\n# Join with new customers to get their risk assessment\nnew_customer_risk = (\n    new_customers\n    .join(risk_assessment, new_customers.entity_id == risk_assessment.node_id)\n    .select([\n        'entity_id',\n        'customer_name',\n        'min_distance_to_blacklist',\n        'avg_distance_to_blacklist',\n        'close_blacklist_count'\n    ])\n)\n\n# Execute the analysis\nresults = new_customer_risk.execute()\n</code></pre>"},{"location":"shortestpaths/#risk-scoring-framework","title":"Risk Scoring Framework","text":"<p>Here's how to interpret and use the distances for risk scoring:</p> <pre><code># Create a more sophisticated risk score\nrisk_scores = (\n    new_customer_risk\n    .mutate(\n        risk_score=ibis.case()\n            .when(risk_assessment.min_distance_to_blacklist &lt;= 1, 1.0)  # Direct connection\n            .when(risk_assessment.min_distance_to_blacklist == 2, 0.7)  # One intermediary\n            .when(risk_assessment.min_distance_to_blacklist == 3, 0.4)  # Two intermediaries\n            .when(risk_assessment.min_distance_to_blacklist == 4, 0.2)  # Three intermediaries\n            .else_(0.1)                                                 # More distant\n    )\n)\n\n# Add risk categories\ncategorized_risks = (\n    risk_scores\n    .mutate(\n        risk_category=ibis.case()\n            .when(risk_scores.risk_score &gt;= 0.8, 'HIGH')\n            .when(risk_scores.risk_score &gt;= 0.5, 'MEDIUM')\n            .else_('LOW')\n    )\n)\n</code></pre>"},{"location":"shortestpaths/#advanced-analysis-techniques","title":"Advanced Analysis Techniques","text":""},{"location":"shortestpaths/#time-based-analysis","title":"Time-Based Analysis","text":"<p>Consider transaction recency in your analysis:</p> <pre><code># Create time-weighted graph\nrecent_transactions = transactions.filter(\n    transactions.transaction_date &gt;= '2024-01-01'\n)\n\n# Separate graphs for different time periods\nrecent_graph = ig.Graph(\n    recent_transactions,\n    source_col='from_entity',\n    target_col='to_entity'\n)\n\nhistorical_graph = ig.Graph(\n    transactions.filter(transactions.transaction_date &lt; '2024-01-01'),\n    source_col='from_entity',\n    target_col='to_entity'\n)\n\n# Compare paths in different time periods\nrecent_paths = ig.traversal.shortest_paths(recent_graph, blacklisted_ids)\nhistorical_paths = ig.traversal.shortest_paths(historical_graph, blacklisted_ids)\n</code></pre>"},{"location":"shortestpaths/#transaction-volume-consideration","title":"Transaction Volume Consideration","text":"<p>Weight paths by transaction volumes:</p> <pre><code># Create graph with transaction amount weights\nweighted_graph = ig.Graph(\n    transactions,\n    source_col='from_entity',\n    target_col='to_entity',\n    weight_col='transaction_amount'\n)\n\n# Higher weights mean stronger connections\nweighted_paths = ig.traveral.shortest_paths(weighted_graph, blacklisted_ids)\n</code></pre>"},{"location":"shortestpaths/#benefits-of-using-ibisgraph-with-snowflake","title":"Benefits of Using IbisGraph with Snowflake","text":"<ol> <li> <p>Data Security</p> <ul> <li>Sensitive transaction data never leaves Snowflake</li> <li>Complies with data governance policies</li> <li>Maintains audit trail within Snowflake</li> </ul> </li> <li> <p>Performance</p> <ul> <li>Leverages Snowflake's computational resources</li> <li>Scales automatically with data volume</li> <li>Efficient processing of large transaction networks</li> </ul> </li> <li> <p>Real-time Analysis</p> <ul> <li>Can be integrated into customer onboarding flows</li> <li>Supports continuous monitoring</li> <li>Easy to update as new transactions occur</li> </ul> </li> <li> <p>Compliance</p> <ul> <li>Maintains data lineage</li> <li>Supports regulatory reporting requirements</li> <li>Provides audit trails for risk decisions</li> </ul> </li> </ol>"},{"location":"shortestpaths/#practical-applications","title":"Practical Applications","text":"<ol> <li> <p>Customer Onboarding</p> <ul> <li>Pre-screen new customers</li> <li>Set initial risk levels</li> <li>Determine required due diligence level</li> </ul> </li> <li> <p>Ongoing Monitoring</p> <ul> <li>Track changes in risk proximity</li> <li>Identify emerging risk patterns</li> <li>Support suspicious activity reporting</li> </ul> </li> <li> <p>Portfolio Risk Management</p> <ul> <li>Assess aggregate exposure to high-risk entities</li> <li>Monitor risk concentration</li> <li>Support strategic decisions</li> </ul> </li> </ol> <p>This approach provides a data-driven, scalable solution for risk assessment while maintaining data security and leveraging existing infrastructure. It can be easily integrated into existing compliance workflows and supports both batch and real-time analysis needs.</p>"},{"location":"similarity/","title":"Using Node Similarity for Business Entity Resolution","text":""},{"location":"similarity/#business-case-identifying-re-registered-businesses","title":"Business Case: Identifying Re-registered Businesses","text":"<p>Banks and financial institutions often face the challenge of identifying businesses that have been re-registered under different names. This information is valuable for:</p> <ul> <li>Cross-selling products that were successful with the original business</li> <li>Risk assessment based on previous business history</li> <li>Marketing and customer relationship management</li> <li>Fraud detection and prevention</li> </ul> <p>The key insight is that even when a business is re-registered under a different name, it often maintains similar transaction patterns with suppliers, customers, and partners.</p>"},{"location":"similarity/#how-jaccard-similarity-helps","title":"How Jaccard Similarity Helps","text":"<p>Jaccard similarity in a transaction graph compares the \"neighborhood\" of each business entity - who they transact with. If two businesses share many common transaction partners relative to their total number of partners, they might be the same business operating under different names.</p> <p>The Jaccard similarity coefficient is calculated as: <pre><code>similarity = |A \u2229 B| / |A \u222a B|\n</code></pre> where A and B are the sets of transaction partners for each business.</p>"},{"location":"similarity/#implementation-with-ibisgraph","title":"Implementation with IbisGraph","text":"<p>Here's how to implement this analysis using IbisGraph while keeping all data processing within your data warehouse:</p> <pre><code>import ibis\nimport ibisgraph as ig\n\n# Connect to your database (e.g., PostgreSQL)\nconn = ibis.postgres.connect(\n    host='your_host',\n    database='your_db',\n    user='your_user',\n    password='your_password'\n)\n\n# Assuming you have a table of transactions\n# transactions_table:\n#   - source_id: business initiating the transaction\n#   - target_id: business receiving the transaction\n#   - amount: transaction amount\n#   - date: transaction date\n\n# Create a graph from recent transactions (e.g., last 6 months)\ntransactions = conn.table('transactions_table')\nrecent_txns = transactions.filter(\n    transactions.date &gt;= '2024-10-01'\n)\n\n# Create a graph from the transactions\ngraph = ig.Graph(\n    recent_txns,\n    source_col='source_id',\n    target_col='target_id'\n)\n\n# Calculate Jaccard similarity between all pairs of businesses\nsimilarity = ig.similarity.jaccard_similarity(graph)\n\n# Filter for highly similar pairs (e.g., similarity &gt; 0.7)\npotential_matches = similarity.filter(similarity.similarity &gt; 0.7)\n\n# If you have business metadata table\nbusiness_info = conn.table('business_info')\n\n# Join with business information for analysis\nresults = (\n    potential_matches\n    .join(\n        business_info.alias('b1'),\n        potential_matches.node1 == business_info.business_id\n    )\n    .join(\n        business_info.alias('b2'),\n        potential_matches.node2 == business_info.business_id\n    )\n    .select([\n        'node1',\n        'node2',\n        'similarity',\n        'b1.business_name',\n        'b1.registration_date',\n        'b2.business_name',\n        'b2.registration_date'\n    ])\n)\n\n# Execute and get results\nmatches = results.execute()\n</code></pre>"},{"location":"similarity/#interpreting-results","title":"Interpreting Results","text":"<p>The results will show pairs of businesses with similar transaction patterns. To identify potential re-registrations, look for:</p> <ol> <li>High similarity score (e.g., &gt; 0.7)</li> <li>Different registration dates</li> <li>Similar business names or addresses (if available)</li> <li>One business being inactive when the other becomes active</li> </ol>"},{"location":"similarity/#additional-considerations","title":"Additional Considerations","text":"<p>To improve the accuracy of matching:</p> <ol> <li>Time Windows: Compare transaction patterns within specific time windows to account for seasonal businesses</li> </ol> <pre><code># Example: Compare patterns in similar seasons\nq1_2024 = transactions.filter(\n    (transactions.date &gt;= '2024-01-01') &amp;\n    (transactions.date &lt; '2024-04-01')\n)\nq1_2023 = transactions.filter(\n    (transactions.date &gt;= '2023-01-01') &amp;\n    (transactions.date &lt; '2023-04-01')\n)\n\n# Create separate graphs and compare\ngraph_2024 = ig.Graph(q1_2024, source_col='source_id', target_col='target_id')\ngraph_2023 = ig.Graph(q1_2023, source_col='source_id', target_col='target_id')\n</code></pre> <ol> <li>Transaction Amounts: Weight edges by transaction amounts to give more importance to significant business relationships</li> </ol> <pre><code># Create a weighted graph\nweighted_graph = ig.Graph(\n    recent_txns,\n    source_col='source_id',\n    target_col='target_id',\n    weight_col='amount'\n)\n</code></pre> <ol> <li>Filter Noise: Remove very common transaction partners (e.g., utility companies) that might create false similarities</li> </ol> <pre><code># Remove high-degree nodes (common transaction partners)\ndegrees = ig.centrality.degrees(graph)\nfiltered_txns = recent_txns.filter(\n    ~recent_txns.target_id.isin(\n        degrees.filter(degrees.degree &gt; 1000).node_id\n    )\n)\n</code></pre>"},{"location":"similarity/#benefits-of-using-ibisgraph","title":"Benefits of Using IbisGraph","text":"<ol> <li>Data Privacy: All processing happens within your data warehouse - sensitive transaction data never leaves your secure environment</li> <li>Scalability: Leverages your database's built-in optimization capabilities</li> <li>Real-time Analysis: Can be integrated into regular monitoring processes</li> <li>Easy Integration: Works with existing data warehouse infrastructure</li> </ol> <p>This approach helps identify business opportunities while maintaining data security and leveraging existing infrastructure. The results can be used by: - Sales teams for cross-selling - Risk teams for credit assessment - Compliance teams for fraud detection - Marketing teams for targeted campaigns</p>"},{"location":"usecases/","title":"Usecases for IbisGraph","text":"<ul> <li>Jaccard Index for Business Entity Resolution</li> <li>Shortest Paths for Compliance</li> <li>PageRank for Financial Networks Analysis</li> </ul>"},{"location":"python/reference/SUMMARY/","title":"Python API","text":"<ul> <li>ibisgraph<ul> <li>centrality<ul> <li>degrees</li> <li>page_rank</li> </ul> </li> <li>clustering<ul> <li>label_propagation</li> </ul> </li> <li>graph</li> <li>pregel<ul> <li>models</li> <li>pregel</li> </ul> </li> <li>similarity<ul> <li>similarity</li> </ul> </li> <li>traversal<ul> <li>shortest_paths</li> </ul> </li> </ul> </li> </ul>"},{"location":"python/reference/ibisgraph/","title":"Index","text":""},{"location":"python/reference/ibisgraph/#ibisgraph.__all__","title":"<code>__all__ = ['IbisGraph', 'IbisGraphConstants', 'centrality', 'clustering', 'traversal', 'similarity']</code>  <code>module-attribute</code>","text":""},{"location":"python/reference/ibisgraph/#ibisgraph.IbisGraph","title":"<code>IbisGraph</code>","text":"<p>A graph representation using Ibis tables for nodes and edges.</p> <p>This class provides a flexible graph data structure that can handle: - Directed and undirected graphs - Optional weighted edges - Integer-based node and edge identifiers</p> <p>Attributes:</p> Name Type Description <code>nodes</code> <code>Table</code> <p>Table containing node information.</p> <code>edges</code> <code>Table</code> <p>Table containing edge connections.</p> <code>directed</code> <code>bool</code> <p>Whether the graph is directed or undirected.</p> <code>num_nodes</code> <code>int</code> <p>Total number of nodes in the graph.</p> <code>num_edges</code> <code>int</code> <p>Total number of edges in the graph.</p> Source code in <code>ibisgraph/graph.py</code> <pre><code>class IbisGraph:\n    \"\"\"A graph representation using Ibis tables for nodes and edges.\n\n    This class provides a flexible graph data structure that can handle:\n    - Directed and undirected graphs\n    - Optional weighted edges\n    - Integer-based node and edge identifiers\n\n    Attributes:\n        nodes (ibis.Table): Table containing node information.\n        edges (ibis.Table): Table containing edge connections.\n        directed (bool): Whether the graph is directed or undirected.\n        num_nodes (int): Total number of nodes in the graph.\n        num_edges (int): Total number of edges in the graph.\n    \"\"\"\n\n    def __init__(\n        self,\n        nodes: ibis.Table,\n        edges: ibis.Table,\n        directed: bool = False,\n        id_col: str = \"id\",\n        src_col: str = \"src\",\n        dst_col: str = \"dst\",\n        weight_col: str | None = None,\n    ) -&gt; None:\n        \"\"\"Initialize an IbisGraph with nodes and edges.\n\n        Args:\n            nodes: Table containing node information.\n            edges: Table containing edge connections.\n            directed: Whether the graph is directed. Defaults to False.\n            id_col: Column name for node IDs. Defaults to \"id\".\n            src_col: Column name for source node in edges. Defaults to \"src\".\n            dst_col: Column name for destination node in edges. Defaults to \"dst\".\n            weight_col: Column name for edge weights. Defaults to None.\n\n        Raises:\n            ValueError: If input columns are missing or have incorrect data types.\n        \"\"\"\n        if id_col not in nodes.schema().keys():\n            raise ValueError(\n                f\"ID column {id_col} is not present. Did you mean one of {nodes.schema().names}\"\n            )\n\n        if not nodes.schema()[id_col].is_integer():\n            raise ValueError(\n                f\"ID data type is {nodes.schema()[id_col]} but only integer-like types are supported for nodes!\"\n            )\n        if src_col not in edges.schema().keys():\n            raise ValueError(\n                f\"ID column {src_col} is not present. Did you mean one of {edges.schema().names}\"\n            )\n        if dst_col not in edges.schema().keys():\n            raise ValueError(\n                f\"ID column {dst_col} is not present. Did you mean one of {edges.schema().names}\"\n            )\n\n        if not edges.schema()[src_col].is_integer():\n            raise ValueError(\n                f\"SRC data type is {edges.schema()[src_col]} but only integer-like types are supported for nodes!\"\n            )\n\n        if not edges.schema()[dst_col].is_integer():\n            raise ValueError(\n                f\"DST data type is {edges.schema()[dst_col]} but only integer-like types are supported for nodes!\"\n            )\n\n        self._nodes = nodes.rename({IbisGraphConstants.ID.value: id_col})\n        self._edges = edges.rename(\n            {IbisGraphConstants.SRC.value: src_col, IbisGraphConstants.DST.value: dst_col}\n        )\n        if weight_col is not None:\n            self._edges = self._edges.rename({IbisGraphConstants.WEIGHT.value: weight_col})\n            self._is_weighted = True\n        else:\n            self._is_weighted = False\n        self._directed = directed\n\n    def set_directed(self, value: bool) -&gt; Self:\n        \"\"\"Set the directionality of the graph.\n\n        Args:\n            value: Whether the graph should be directed or undirected.\n\n        Returns:\n            The current graph instance for method chaining.\n        \"\"\"\n        self._directed = value\n        return self\n\n    @property\n    def nodes(self) -&gt; ibis.Table:\n        \"\"\"Get the nodes table of the graph.\n\n        Returns:\n            A table containing node information with node identifiers.\n        \"\"\"\n        return self._nodes\n\n    @property\n    def edges(self) -&gt; ibis.Table:\n        \"\"\"Get the edges table of the graph.\n\n        Returns:\n            A table containing edges information with edges identifiers.\n        \"\"\"\n        return self._edges\n\n    @property\n    def num_nodes(self) -&gt; int:\n        \"\"\"Get the number of nodes in the graph.\n\n        Returns:\n            The total number of nodes in the graph.\n        \"\"\"\n        return int(self._nodes.count().to_pandas())\n\n    @property\n    def num_edges(self) -&gt; int:\n        \"\"\"Get the number of edges in the graph.\n\n        Returns:\n            The total number of edges in the graph.\n        \"\"\"\n        return int(self._edges.count().to_pandas())\n\n    @property\n    def is_directed(self) -&gt; bool:\n        \"\"\"Check if the graph is directed.\n\n        Returns:\n            True if the graph is directed, False otherwise.\n        \"\"\"\n        return self._directed\n</code></pre>"},{"location":"python/reference/ibisgraph/#ibisgraph.IbisGraph.edges","title":"<code>edges</code>  <code>property</code>","text":"<p>Get the edges table of the graph.</p> <p>Returns:</p> Type Description <code>Table</code> <p>A table containing edges information with edges identifiers.</p>"},{"location":"python/reference/ibisgraph/#ibisgraph.IbisGraph.is_directed","title":"<code>is_directed</code>  <code>property</code>","text":"<p>Check if the graph is directed.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the graph is directed, False otherwise.</p>"},{"location":"python/reference/ibisgraph/#ibisgraph.IbisGraph.nodes","title":"<code>nodes</code>  <code>property</code>","text":"<p>Get the nodes table of the graph.</p> <p>Returns:</p> Type Description <code>Table</code> <p>A table containing node information with node identifiers.</p>"},{"location":"python/reference/ibisgraph/#ibisgraph.IbisGraph.num_edges","title":"<code>num_edges</code>  <code>property</code>","text":"<p>Get the number of edges in the graph.</p> <p>Returns:</p> Type Description <code>int</code> <p>The total number of edges in the graph.</p>"},{"location":"python/reference/ibisgraph/#ibisgraph.IbisGraph.num_nodes","title":"<code>num_nodes</code>  <code>property</code>","text":"<p>Get the number of nodes in the graph.</p> <p>Returns:</p> Type Description <code>int</code> <p>The total number of nodes in the graph.</p>"},{"location":"python/reference/ibisgraph/#ibisgraph.IbisGraph.__init__","title":"<code>__init__(nodes, edges, directed=False, id_col='id', src_col='src', dst_col='dst', weight_col=None)</code>","text":"<p>Initialize an IbisGraph with nodes and edges.</p> <p>Parameters:</p> Name Type Description Default <code>nodes</code> <code>Table</code> <p>Table containing node information.</p> required <code>edges</code> <code>Table</code> <p>Table containing edge connections.</p> required <code>directed</code> <code>bool</code> <p>Whether the graph is directed. Defaults to False.</p> <code>False</code> <code>id_col</code> <code>str</code> <p>Column name for node IDs. Defaults to \"id\".</p> <code>'id'</code> <code>src_col</code> <code>str</code> <p>Column name for source node in edges. Defaults to \"src\".</p> <code>'src'</code> <code>dst_col</code> <code>str</code> <p>Column name for destination node in edges. Defaults to \"dst\".</p> <code>'dst'</code> <code>weight_col</code> <code>str | None</code> <p>Column name for edge weights. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If input columns are missing or have incorrect data types.</p> Source code in <code>ibisgraph/graph.py</code> <pre><code>def __init__(\n    self,\n    nodes: ibis.Table,\n    edges: ibis.Table,\n    directed: bool = False,\n    id_col: str = \"id\",\n    src_col: str = \"src\",\n    dst_col: str = \"dst\",\n    weight_col: str | None = None,\n) -&gt; None:\n    \"\"\"Initialize an IbisGraph with nodes and edges.\n\n    Args:\n        nodes: Table containing node information.\n        edges: Table containing edge connections.\n        directed: Whether the graph is directed. Defaults to False.\n        id_col: Column name for node IDs. Defaults to \"id\".\n        src_col: Column name for source node in edges. Defaults to \"src\".\n        dst_col: Column name for destination node in edges. Defaults to \"dst\".\n        weight_col: Column name for edge weights. Defaults to None.\n\n    Raises:\n        ValueError: If input columns are missing or have incorrect data types.\n    \"\"\"\n    if id_col not in nodes.schema().keys():\n        raise ValueError(\n            f\"ID column {id_col} is not present. Did you mean one of {nodes.schema().names}\"\n        )\n\n    if not nodes.schema()[id_col].is_integer():\n        raise ValueError(\n            f\"ID data type is {nodes.schema()[id_col]} but only integer-like types are supported for nodes!\"\n        )\n    if src_col not in edges.schema().keys():\n        raise ValueError(\n            f\"ID column {src_col} is not present. Did you mean one of {edges.schema().names}\"\n        )\n    if dst_col not in edges.schema().keys():\n        raise ValueError(\n            f\"ID column {dst_col} is not present. Did you mean one of {edges.schema().names}\"\n        )\n\n    if not edges.schema()[src_col].is_integer():\n        raise ValueError(\n            f\"SRC data type is {edges.schema()[src_col]} but only integer-like types are supported for nodes!\"\n        )\n\n    if not edges.schema()[dst_col].is_integer():\n        raise ValueError(\n            f\"DST data type is {edges.schema()[dst_col]} but only integer-like types are supported for nodes!\"\n        )\n\n    self._nodes = nodes.rename({IbisGraphConstants.ID.value: id_col})\n    self._edges = edges.rename(\n        {IbisGraphConstants.SRC.value: src_col, IbisGraphConstants.DST.value: dst_col}\n    )\n    if weight_col is not None:\n        self._edges = self._edges.rename({IbisGraphConstants.WEIGHT.value: weight_col})\n        self._is_weighted = True\n    else:\n        self._is_weighted = False\n    self._directed = directed\n</code></pre>"},{"location":"python/reference/ibisgraph/#ibisgraph.IbisGraph.set_directed","title":"<code>set_directed(value)</code>","text":"<p>Set the directionality of the graph.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>bool</code> <p>Whether the graph should be directed or undirected.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>The current graph instance for method chaining.</p> Source code in <code>ibisgraph/graph.py</code> <pre><code>def set_directed(self, value: bool) -&gt; Self:\n    \"\"\"Set the directionality of the graph.\n\n    Args:\n        value: Whether the graph should be directed or undirected.\n\n    Returns:\n        The current graph instance for method chaining.\n    \"\"\"\n    self._directed = value\n    return self\n</code></pre>"},{"location":"python/reference/ibisgraph/#ibisgraph.IbisGraphConstants","title":"<code>IbisGraphConstants</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Constants for standardizing column names and identifiers in graph data structures.</p> <p>These constants provide a consistent naming convention for graph-related columns to ensure compatibility and ease of use across different graph processing operations.</p> Source code in <code>ibisgraph/graph.py</code> <pre><code>class IbisGraphConstants(Enum):\n    \"\"\"Constants for standardizing column names and identifiers in graph data structures.\n\n    These constants provide a consistent naming convention for graph-related columns\n    to ensure compatibility and ease of use across different graph processing operations.\n    \"\"\"\n\n    ID = \"id_\"\n    SRC = \"src_\"\n    DST = \"dst_\"\n    WEIGHT = \"weight_\"\n    EDGE = \"edge_\"\n</code></pre>"},{"location":"python/reference/ibisgraph/#ibisgraph.IbisGraphConstants.DST","title":"<code>DST = 'dst_'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"python/reference/ibisgraph/#ibisgraph.IbisGraphConstants.EDGE","title":"<code>EDGE = 'edge_'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"python/reference/ibisgraph/#ibisgraph.IbisGraphConstants.ID","title":"<code>ID = 'id_'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"python/reference/ibisgraph/#ibisgraph.IbisGraphConstants.SRC","title":"<code>SRC = 'src_'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"python/reference/ibisgraph/#ibisgraph.IbisGraphConstants.WEIGHT","title":"<code>WEIGHT = 'weight_'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"python/reference/ibisgraph/graph/","title":"Graph","text":""},{"location":"python/reference/ibisgraph/graph/#ibisgraph.graph.IbisGraph","title":"<code>IbisGraph</code>","text":"<p>A graph representation using Ibis tables for nodes and edges.</p> <p>This class provides a flexible graph data structure that can handle: - Directed and undirected graphs - Optional weighted edges - Integer-based node and edge identifiers</p> <p>Attributes:</p> Name Type Description <code>nodes</code> <code>Table</code> <p>Table containing node information.</p> <code>edges</code> <code>Table</code> <p>Table containing edge connections.</p> <code>directed</code> <code>bool</code> <p>Whether the graph is directed or undirected.</p> <code>num_nodes</code> <code>int</code> <p>Total number of nodes in the graph.</p> <code>num_edges</code> <code>int</code> <p>Total number of edges in the graph.</p> Source code in <code>ibisgraph/graph.py</code> <pre><code>class IbisGraph:\n    \"\"\"A graph representation using Ibis tables for nodes and edges.\n\n    This class provides a flexible graph data structure that can handle:\n    - Directed and undirected graphs\n    - Optional weighted edges\n    - Integer-based node and edge identifiers\n\n    Attributes:\n        nodes (ibis.Table): Table containing node information.\n        edges (ibis.Table): Table containing edge connections.\n        directed (bool): Whether the graph is directed or undirected.\n        num_nodes (int): Total number of nodes in the graph.\n        num_edges (int): Total number of edges in the graph.\n    \"\"\"\n\n    def __init__(\n        self,\n        nodes: ibis.Table,\n        edges: ibis.Table,\n        directed: bool = False,\n        id_col: str = \"id\",\n        src_col: str = \"src\",\n        dst_col: str = \"dst\",\n        weight_col: str | None = None,\n    ) -&gt; None:\n        \"\"\"Initialize an IbisGraph with nodes and edges.\n\n        Args:\n            nodes: Table containing node information.\n            edges: Table containing edge connections.\n            directed: Whether the graph is directed. Defaults to False.\n            id_col: Column name for node IDs. Defaults to \"id\".\n            src_col: Column name for source node in edges. Defaults to \"src\".\n            dst_col: Column name for destination node in edges. Defaults to \"dst\".\n            weight_col: Column name for edge weights. Defaults to None.\n\n        Raises:\n            ValueError: If input columns are missing or have incorrect data types.\n        \"\"\"\n        if id_col not in nodes.schema().keys():\n            raise ValueError(\n                f\"ID column {id_col} is not present. Did you mean one of {nodes.schema().names}\"\n            )\n\n        if not nodes.schema()[id_col].is_integer():\n            raise ValueError(\n                f\"ID data type is {nodes.schema()[id_col]} but only integer-like types are supported for nodes!\"\n            )\n        if src_col not in edges.schema().keys():\n            raise ValueError(\n                f\"ID column {src_col} is not present. Did you mean one of {edges.schema().names}\"\n            )\n        if dst_col not in edges.schema().keys():\n            raise ValueError(\n                f\"ID column {dst_col} is not present. Did you mean one of {edges.schema().names}\"\n            )\n\n        if not edges.schema()[src_col].is_integer():\n            raise ValueError(\n                f\"SRC data type is {edges.schema()[src_col]} but only integer-like types are supported for nodes!\"\n            )\n\n        if not edges.schema()[dst_col].is_integer():\n            raise ValueError(\n                f\"DST data type is {edges.schema()[dst_col]} but only integer-like types are supported for nodes!\"\n            )\n\n        self._nodes = nodes.rename({IbisGraphConstants.ID.value: id_col})\n        self._edges = edges.rename(\n            {IbisGraphConstants.SRC.value: src_col, IbisGraphConstants.DST.value: dst_col}\n        )\n        if weight_col is not None:\n            self._edges = self._edges.rename({IbisGraphConstants.WEIGHT.value: weight_col})\n            self._is_weighted = True\n        else:\n            self._is_weighted = False\n        self._directed = directed\n\n    def set_directed(self, value: bool) -&gt; Self:\n        \"\"\"Set the directionality of the graph.\n\n        Args:\n            value: Whether the graph should be directed or undirected.\n\n        Returns:\n            The current graph instance for method chaining.\n        \"\"\"\n        self._directed = value\n        return self\n\n    @property\n    def nodes(self) -&gt; ibis.Table:\n        \"\"\"Get the nodes table of the graph.\n\n        Returns:\n            A table containing node information with node identifiers.\n        \"\"\"\n        return self._nodes\n\n    @property\n    def edges(self) -&gt; ibis.Table:\n        \"\"\"Get the edges table of the graph.\n\n        Returns:\n            A table containing edges information with edges identifiers.\n        \"\"\"\n        return self._edges\n\n    @property\n    def num_nodes(self) -&gt; int:\n        \"\"\"Get the number of nodes in the graph.\n\n        Returns:\n            The total number of nodes in the graph.\n        \"\"\"\n        return int(self._nodes.count().to_pandas())\n\n    @property\n    def num_edges(self) -&gt; int:\n        \"\"\"Get the number of edges in the graph.\n\n        Returns:\n            The total number of edges in the graph.\n        \"\"\"\n        return int(self._edges.count().to_pandas())\n\n    @property\n    def is_directed(self) -&gt; bool:\n        \"\"\"Check if the graph is directed.\n\n        Returns:\n            True if the graph is directed, False otherwise.\n        \"\"\"\n        return self._directed\n</code></pre>"},{"location":"python/reference/ibisgraph/graph/#ibisgraph.graph.IbisGraph.edges","title":"<code>edges</code>  <code>property</code>","text":"<p>Get the edges table of the graph.</p> <p>Returns:</p> Type Description <code>Table</code> <p>A table containing edges information with edges identifiers.</p>"},{"location":"python/reference/ibisgraph/graph/#ibisgraph.graph.IbisGraph.is_directed","title":"<code>is_directed</code>  <code>property</code>","text":"<p>Check if the graph is directed.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the graph is directed, False otherwise.</p>"},{"location":"python/reference/ibisgraph/graph/#ibisgraph.graph.IbisGraph.nodes","title":"<code>nodes</code>  <code>property</code>","text":"<p>Get the nodes table of the graph.</p> <p>Returns:</p> Type Description <code>Table</code> <p>A table containing node information with node identifiers.</p>"},{"location":"python/reference/ibisgraph/graph/#ibisgraph.graph.IbisGraph.num_edges","title":"<code>num_edges</code>  <code>property</code>","text":"<p>Get the number of edges in the graph.</p> <p>Returns:</p> Type Description <code>int</code> <p>The total number of edges in the graph.</p>"},{"location":"python/reference/ibisgraph/graph/#ibisgraph.graph.IbisGraph.num_nodes","title":"<code>num_nodes</code>  <code>property</code>","text":"<p>Get the number of nodes in the graph.</p> <p>Returns:</p> Type Description <code>int</code> <p>The total number of nodes in the graph.</p>"},{"location":"python/reference/ibisgraph/graph/#ibisgraph.graph.IbisGraph.__init__","title":"<code>__init__(nodes, edges, directed=False, id_col='id', src_col='src', dst_col='dst', weight_col=None)</code>","text":"<p>Initialize an IbisGraph with nodes and edges.</p> <p>Parameters:</p> Name Type Description Default <code>nodes</code> <code>Table</code> <p>Table containing node information.</p> required <code>edges</code> <code>Table</code> <p>Table containing edge connections.</p> required <code>directed</code> <code>bool</code> <p>Whether the graph is directed. Defaults to False.</p> <code>False</code> <code>id_col</code> <code>str</code> <p>Column name for node IDs. Defaults to \"id\".</p> <code>'id'</code> <code>src_col</code> <code>str</code> <p>Column name for source node in edges. Defaults to \"src\".</p> <code>'src'</code> <code>dst_col</code> <code>str</code> <p>Column name for destination node in edges. Defaults to \"dst\".</p> <code>'dst'</code> <code>weight_col</code> <code>str | None</code> <p>Column name for edge weights. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If input columns are missing or have incorrect data types.</p> Source code in <code>ibisgraph/graph.py</code> <pre><code>def __init__(\n    self,\n    nodes: ibis.Table,\n    edges: ibis.Table,\n    directed: bool = False,\n    id_col: str = \"id\",\n    src_col: str = \"src\",\n    dst_col: str = \"dst\",\n    weight_col: str | None = None,\n) -&gt; None:\n    \"\"\"Initialize an IbisGraph with nodes and edges.\n\n    Args:\n        nodes: Table containing node information.\n        edges: Table containing edge connections.\n        directed: Whether the graph is directed. Defaults to False.\n        id_col: Column name for node IDs. Defaults to \"id\".\n        src_col: Column name for source node in edges. Defaults to \"src\".\n        dst_col: Column name for destination node in edges. Defaults to \"dst\".\n        weight_col: Column name for edge weights. Defaults to None.\n\n    Raises:\n        ValueError: If input columns are missing or have incorrect data types.\n    \"\"\"\n    if id_col not in nodes.schema().keys():\n        raise ValueError(\n            f\"ID column {id_col} is not present. Did you mean one of {nodes.schema().names}\"\n        )\n\n    if not nodes.schema()[id_col].is_integer():\n        raise ValueError(\n            f\"ID data type is {nodes.schema()[id_col]} but only integer-like types are supported for nodes!\"\n        )\n    if src_col not in edges.schema().keys():\n        raise ValueError(\n            f\"ID column {src_col} is not present. Did you mean one of {edges.schema().names}\"\n        )\n    if dst_col not in edges.schema().keys():\n        raise ValueError(\n            f\"ID column {dst_col} is not present. Did you mean one of {edges.schema().names}\"\n        )\n\n    if not edges.schema()[src_col].is_integer():\n        raise ValueError(\n            f\"SRC data type is {edges.schema()[src_col]} but only integer-like types are supported for nodes!\"\n        )\n\n    if not edges.schema()[dst_col].is_integer():\n        raise ValueError(\n            f\"DST data type is {edges.schema()[dst_col]} but only integer-like types are supported for nodes!\"\n        )\n\n    self._nodes = nodes.rename({IbisGraphConstants.ID.value: id_col})\n    self._edges = edges.rename(\n        {IbisGraphConstants.SRC.value: src_col, IbisGraphConstants.DST.value: dst_col}\n    )\n    if weight_col is not None:\n        self._edges = self._edges.rename({IbisGraphConstants.WEIGHT.value: weight_col})\n        self._is_weighted = True\n    else:\n        self._is_weighted = False\n    self._directed = directed\n</code></pre>"},{"location":"python/reference/ibisgraph/graph/#ibisgraph.graph.IbisGraph.set_directed","title":"<code>set_directed(value)</code>","text":"<p>Set the directionality of the graph.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>bool</code> <p>Whether the graph should be directed or undirected.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>The current graph instance for method chaining.</p> Source code in <code>ibisgraph/graph.py</code> <pre><code>def set_directed(self, value: bool) -&gt; Self:\n    \"\"\"Set the directionality of the graph.\n\n    Args:\n        value: Whether the graph should be directed or undirected.\n\n    Returns:\n        The current graph instance for method chaining.\n    \"\"\"\n    self._directed = value\n    return self\n</code></pre>"},{"location":"python/reference/ibisgraph/graph/#ibisgraph.graph.IbisGraphConstants","title":"<code>IbisGraphConstants</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Constants for standardizing column names and identifiers in graph data structures.</p> <p>These constants provide a consistent naming convention for graph-related columns to ensure compatibility and ease of use across different graph processing operations.</p> Source code in <code>ibisgraph/graph.py</code> <pre><code>class IbisGraphConstants(Enum):\n    \"\"\"Constants for standardizing column names and identifiers in graph data structures.\n\n    These constants provide a consistent naming convention for graph-related columns\n    to ensure compatibility and ease of use across different graph processing operations.\n    \"\"\"\n\n    ID = \"id_\"\n    SRC = \"src_\"\n    DST = \"dst_\"\n    WEIGHT = \"weight_\"\n    EDGE = \"edge_\"\n</code></pre>"},{"location":"python/reference/ibisgraph/graph/#ibisgraph.graph.IbisGraphConstants.DST","title":"<code>DST = 'dst_'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"python/reference/ibisgraph/graph/#ibisgraph.graph.IbisGraphConstants.EDGE","title":"<code>EDGE = 'edge_'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"python/reference/ibisgraph/graph/#ibisgraph.graph.IbisGraphConstants.ID","title":"<code>ID = 'id_'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"python/reference/ibisgraph/graph/#ibisgraph.graph.IbisGraphConstants.SRC","title":"<code>SRC = 'src_'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"python/reference/ibisgraph/graph/#ibisgraph.graph.IbisGraphConstants.WEIGHT","title":"<code>WEIGHT = 'weight_'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"python/reference/ibisgraph/centrality/","title":"Index","text":""},{"location":"python/reference/ibisgraph/centrality/#ibisgraph.centrality.__all__","title":"<code>__all__ = ['in_degrees', 'out_degrees', 'degrees', 'page_rank']</code>  <code>module-attribute</code>","text":""},{"location":"python/reference/ibisgraph/centrality/#ibisgraph.centrality.in_degrees","title":"<code>in_degrees(graph)</code>","text":"<p>Calculate the in-degrees for each node in a directed graph.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>IbisGraph</code> <p>A directed graph for which to calculate in-degrees.</p> required <p>Returns:</p> Type Description <code>Table</code> <p>A table with columns 'node_id' and 'in_degree', representing the</p> <code>Table</code> <p>number of incoming edges for each node.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the graph is undirected, as in-degrees are only meaningful for directed graphs.</p> Source code in <code>ibisgraph/centrality/degrees.py</code> <pre><code>def in_degrees(graph: IbisGraph) -&gt; ibis.Table:\n    \"\"\"Calculate the in-degrees for each node in a directed graph.\n\n    Args:\n        graph: A directed graph for which to calculate in-degrees.\n\n    Returns:\n        A table with columns 'node_id' and 'in_degree', representing the\n        number of incoming edges for each node.\n\n    Raises:\n        ValueError: If the graph is undirected, as in-degrees are only\n            meaningful for directed graphs.\n    \"\"\"\n    if not graph._directed:\n        raise ValueError(\"In-degrees for undirected graph is ambiguous.\")\n    edges = graph._edges\n    return edges.group_by(edges[IbisGraphConstants.DST.value].name(\"node_id\")).aggregate(\n        ibis._.count().name(\"in_degree\")\n    )\n</code></pre>"},{"location":"python/reference/ibisgraph/centrality/#ibisgraph.centrality.out_degrees","title":"<code>out_degrees(graph)</code>","text":"<p>Calculate the out-degrees for each node in a directed graph.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>IbisGraph</code> <p>A directed graph for which to calculate out-degrees.</p> required <p>Returns:</p> Type Description <code>Table</code> <p>A table with columns 'node_id' and 'out_degree', representing the</p> <code>Table</code> <p>number of outgoing edges for each node.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the graph is undirected, as out-degrees are only meaningful for directed graphs.</p> Source code in <code>ibisgraph/centrality/degrees.py</code> <pre><code>def out_degrees(graph: IbisGraph) -&gt; ibis.Table:\n    \"\"\"Calculate the out-degrees for each node in a directed graph.\n\n    Args:\n        graph: A directed graph for which to calculate out-degrees.\n\n    Returns:\n        A table with columns 'node_id' and 'out_degree', representing the\n        number of outgoing edges for each node.\n\n    Raises:\n        ValueError: If the graph is undirected, as out-degrees are only\n            meaningful for directed graphs.\n    \"\"\"\n    if not graph._directed:\n        raise ValueError(\"Out-degrees for undirected graph is ambiguous.\")\n    edges = graph._edges\n    return edges.group_by(edges[IbisGraphConstants.SRC.value].name(\"node_id\")).aggregate(\n        ibis._.count().name(\"out_degree\")\n    )\n</code></pre>"},{"location":"python/reference/ibisgraph/centrality/degrees/","title":"Degrees","text":""},{"location":"python/reference/ibisgraph/centrality/degrees/#ibisgraph.centrality.degrees.degrees","title":"<code>degrees(graph)</code>","text":"<p>Calculate the degrees for each node in a graph.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>IbisGraph</code> <p>A graph for which to calculate degrees.</p> required <p>Returns:</p> Type Description <code>Table</code> <p>A table with columns 'node_id' and 'degree', representing the</p> <code>Table</code> <p>number of edges for each node.</p> Source code in <code>ibisgraph/centrality/degrees.py</code> <pre><code>def degrees(graph: IbisGraph) -&gt; ibis.Table:\n    \"\"\"Calculate the degrees for each node in a graph.\n\n    Args:\n        graph: A graph for which to calculate degrees.\n\n    Returns:\n        A table with columns 'node_id' and 'degree', representing the\n        number of edges for each node.\n    \"\"\"\n    edges = graph._edges\n    return (\n        edges.select(\n            ibis.array([ibis._[IbisGraphConstants.SRC.value], ibis._[IbisGraphConstants.DST.value]])\n            .unnest()\n            .name(\"node_id\")\n        )\n        .group_by(\"node_id\")\n        .aggregate(ibis._.count().name(\"degree\"))\n    )\n</code></pre>"},{"location":"python/reference/ibisgraph/centrality/degrees/#ibisgraph.centrality.degrees.in_degrees","title":"<code>in_degrees(graph)</code>","text":"<p>Calculate the in-degrees for each node in a directed graph.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>IbisGraph</code> <p>A directed graph for which to calculate in-degrees.</p> required <p>Returns:</p> Type Description <code>Table</code> <p>A table with columns 'node_id' and 'in_degree', representing the</p> <code>Table</code> <p>number of incoming edges for each node.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the graph is undirected, as in-degrees are only meaningful for directed graphs.</p> Source code in <code>ibisgraph/centrality/degrees.py</code> <pre><code>def in_degrees(graph: IbisGraph) -&gt; ibis.Table:\n    \"\"\"Calculate the in-degrees for each node in a directed graph.\n\n    Args:\n        graph: A directed graph for which to calculate in-degrees.\n\n    Returns:\n        A table with columns 'node_id' and 'in_degree', representing the\n        number of incoming edges for each node.\n\n    Raises:\n        ValueError: If the graph is undirected, as in-degrees are only\n            meaningful for directed graphs.\n    \"\"\"\n    if not graph._directed:\n        raise ValueError(\"In-degrees for undirected graph is ambiguous.\")\n    edges = graph._edges\n    return edges.group_by(edges[IbisGraphConstants.DST.value].name(\"node_id\")).aggregate(\n        ibis._.count().name(\"in_degree\")\n    )\n</code></pre>"},{"location":"python/reference/ibisgraph/centrality/degrees/#ibisgraph.centrality.degrees.out_degrees","title":"<code>out_degrees(graph)</code>","text":"<p>Calculate the out-degrees for each node in a directed graph.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>IbisGraph</code> <p>A directed graph for which to calculate out-degrees.</p> required <p>Returns:</p> Type Description <code>Table</code> <p>A table with columns 'node_id' and 'out_degree', representing the</p> <code>Table</code> <p>number of outgoing edges for each node.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the graph is undirected, as out-degrees are only meaningful for directed graphs.</p> Source code in <code>ibisgraph/centrality/degrees.py</code> <pre><code>def out_degrees(graph: IbisGraph) -&gt; ibis.Table:\n    \"\"\"Calculate the out-degrees for each node in a directed graph.\n\n    Args:\n        graph: A directed graph for which to calculate out-degrees.\n\n    Returns:\n        A table with columns 'node_id' and 'out_degree', representing the\n        number of outgoing edges for each node.\n\n    Raises:\n        ValueError: If the graph is undirected, as out-degrees are only\n            meaningful for directed graphs.\n    \"\"\"\n    if not graph._directed:\n        raise ValueError(\"Out-degrees for undirected graph is ambiguous.\")\n    edges = graph._edges\n    return edges.group_by(edges[IbisGraphConstants.SRC.value].name(\"node_id\")).aggregate(\n        ibis._.count().name(\"out_degree\")\n    )\n</code></pre>"},{"location":"python/reference/ibisgraph/centrality/page_rank/","title":"Page rank","text":""},{"location":"python/reference/ibisgraph/centrality/page_rank/#ibisgraph.centrality.page_rank.PAGERANK_NODE_COL_NAME","title":"<code>PAGERANK_NODE_COL_NAME = 'node_id'</code>  <code>module-attribute</code>","text":""},{"location":"python/reference/ibisgraph/centrality/page_rank/#ibisgraph.centrality.page_rank.PAGERANK_SCORE_COL_NAME","title":"<code>PAGERANK_SCORE_COL_NAME = 'pagerank'</code>  <code>module-attribute</code>","text":""},{"location":"python/reference/ibisgraph/centrality/page_rank/#ibisgraph.centrality.page_rank.page_rank","title":"<code>page_rank(graph, alpha=0.85, max_iters=20, checkpoint_interval=1, tol=0.0001)</code>","text":"<p>Compute PageRank for a graph using the Pregel iterative algorithm.</p> <p>PageRank measures the importance of nodes in a graph based on the structure of incoming links. The algorithm simulates a random walk through the graph, where a hypothetical 'random surfer' follows links with probability <code>alpha</code> and jumps to a random node with probability <code>1 - alpha</code>.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>IbisGraph</code> <p>The input graph for PageRank computation.</p> required <code>alpha</code> <code>float</code> <p>Damping factor controlling random walk probability. Must be between 0 and 1. Defaults to 0.85.</p> <code>0.85</code> <code>max_iters</code> <code>int</code> <p>Maximum number of iterations. Defaults to 20.</p> <code>20</code> <code>checkpoint_interval</code> <code>int</code> <p>Interval for checkpointing. Defaults to 1. Recommended to keep at 1 for single-node/in-memory backends. For distributed engines like Apache Spark, larger values are recommended.</p> <code>1</code> <code>tol</code> <code>float</code> <p>Convergence tolerance. Stops when score changes are below this value. Defaults to 1e-4.</p> <code>0.0001</code> <p>Returns:</p> Type Description <code>Table</code> <p>A table with node IDs (column \"node_id\") and their corresponding PageRank scores</p> <code>Table</code> <p>(column \"pagerank\").</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If alpha is not between 0 and 1.</p> Note <ul> <li>For convergence-based stopping: Set max_iter high and control flow with tol.</li> <li>For fixed iterations: Set tol to 0 and control flow with max_iter.</li> <li>While this implementation supports undirected graphs, PageRank is not   clearly defined for such graphs.</li> </ul> Source code in <code>ibisgraph/centrality/page_rank.py</code> <pre><code>def page_rank(\n    graph: IbisGraph,\n    alpha: float = 0.85,\n    max_iters: int = 20,\n    checkpoint_interval: int = 1,\n    tol: float = 1e-4,\n) -&gt; ibis.Table:\n    \"\"\"Compute PageRank for a graph using the Pregel iterative algorithm.\n\n    PageRank measures the importance of nodes in a graph based on the structure of incoming links.\n    The algorithm simulates a random walk through the graph, where a hypothetical 'random surfer'\n    follows links with probability `alpha` and jumps to a random node with probability `1 - alpha`.\n\n    Args:\n        graph: The input graph for PageRank computation.\n        alpha: Damping factor controlling random walk probability. Must be between 0 and 1.\n            Defaults to 0.85.\n        max_iters: Maximum number of iterations. Defaults to 20.\n        checkpoint_interval: Interval for checkpointing. Defaults to 1.\n            Recommended to keep at 1 for single-node/in-memory backends.\n            For distributed engines like Apache Spark, larger values are recommended.\n        tol: Convergence tolerance. Stops when score changes are below this value.\n            Defaults to 1e-4.\n\n    Returns:\n        A table with node IDs (column \"node_id\") and their corresponding PageRank scores\n        (column \"pagerank\").\n\n    Raises:\n        ValueError: If alpha is not between 0 and 1.\n\n    Note:\n        - For convergence-based stopping: Set max_iter high and control flow with tol.\n        - For fixed iterations: Set tol to 0 and control flow with max_iter.\n        - While this implementation supports undirected graphs, PageRank is not\n          clearly defined for such graphs.\n    \"\"\"\n    if (alpha &lt;= 0) or (alpha &gt;= 1.0):\n        raise ValueError(f\"Expected 0 &lt;= alpha &lt; 1.0 but got {alpha}.\")\n    num_nodes = graph.num_nodes\n    coeff = (1 - alpha) / num_nodes\n    initial_scores = 1.0 / num_nodes\n    if graph.is_directed:\n        tmp_degrees = out_degrees(graph).rename(\n            {IbisGraphConstants.ID.value: \"node_id\", \"degree\": \"out_degree\"}\n        )\n    else:\n        tmp_degrees = degrees(graph).rename({IbisGraphConstants.ID.value: \"node_id\"})\n    nodes_with_degrees = graph.nodes.join(tmp_degrees, [IbisGraphConstants.ID.value])\n    new_g = IbisGraph(\n        nodes_with_degrees,\n        graph.edges,\n        id_col=IbisGraphConstants.ID.value,\n        src_col=IbisGraphConstants.SRC.value,\n        dst_col=IbisGraphConstants.DST.value,\n    )\n    pregel = Pregel(new_g)\n\n    rank_upd_expr = ibis.ifelse(\n        pregel.pregel_msg().isnull(), ibis.literal(0.0), pregel.pregel_msg()\n    ) * ibis.literal(alpha) + ibis.literal(coeff)\n\n    pregel = (\n        pregel.add_vertex_col(\n            PAGERANK_SCORE_COL_NAME,\n            ibis.literal(initial_scores),\n            rank_upd_expr,\n        )\n        .add_vertex_col(\n            \"err\",\n            ibis.literal(100.0),\n            (ibis._[PAGERANK_SCORE_COL_NAME] - rank_upd_expr).abs(),\n        )\n        .add_message_to_dst(\n            pregel.pregel_src(PAGERANK_SCORE_COL_NAME) / pregel.pregel_src(\"degree\")\n        )\n        .set_agg_expression_func(lambda msg: msg.collect().sums())\n        .set_has_active_flag(True)\n        .set_active_flag_upd_col(ibis._[\"err\"] &gt;= tol)\n        .set_early_stopping(True)\n        .set_max_iter(max_iters)\n        .set_stop_if_all_unactive(True)\n    )\n\n    if not graph.is_directed:\n        pregel = pregel.add_message_to_src(\n            pregel.pregel_dst(PAGERANK_SCORE_COL_NAME) / pregel.pregel_dst(\"degree\")\n        )\n\n    output = pregel.run()\n    return output.rename({PAGERANK_NODE_COL_NAME: IbisGraphConstants.ID.value}).select(\n        PAGERANK_NODE_COL_NAME, PAGERANK_SCORE_COL_NAME\n    )\n</code></pre>"},{"location":"python/reference/ibisgraph/clustering/","title":"Index","text":""},{"location":"python/reference/ibisgraph/clustering/#ibisgraph.clustering.__all__","title":"<code>__all__ = ['label_propagation']</code>  <code>module-attribute</code>","text":""},{"location":"python/reference/ibisgraph/clustering/label_propagation/","title":"Label propagation","text":""},{"location":"python/reference/ibisgraph/clustering/label_propagation/#ibisgraph.clustering.label_propagation.LABEL_COL_NAME","title":"<code>LABEL_COL_NAME = 'label'</code>  <code>module-attribute</code>","text":""},{"location":"python/reference/ibisgraph/clustering/label_propagation/#ibisgraph.clustering.label_propagation.NODE_COL_NAME","title":"<code>NODE_COL_NAME = 'node_id'</code>  <code>module-attribute</code>","text":""},{"location":"python/reference/ibisgraph/clustering/label_propagation/#ibisgraph.clustering.label_propagation.label_propagation","title":"<code>label_propagation(graph, max_iter=30, checkpoint_interval=1, sort_labels=False)</code>","text":"<p>Perform Label Propagation clustering on a graph with Pregel.</p> <p>Label Propagation is an iterative algorithm that assigns labels to nodes based on the labels of their neighbors. Each node initially starts with its own unique label and then iteratively adopts the most frequent label among its neighbors.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>IbisGraph</code> <p>Input graph to perform clustering on.</p> required <code>max_iter</code> <code>int</code> <p>Maximum number of iterations. Defaults to 30.</p> <code>30</code> <code>checkpoint_interval</code> <code>int</code> <p>Interval for checkpointing. Defaults to 1. Recommended to keep at 1 for single-node/in-memory backends. For distributed engines like Apache Spark, larger values are recommended.</p> <code>1</code> <code>sort_labels</code> <code>bool</code> <p>If True, sort labels before selecting mode. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Table</code> <p>A table with two columns:</p> <code>Table</code> <ul> <li>'node_id': Original node identifiers</li> </ul> <code>Table</code> <ul> <li>'label': Assigned cluster label for each node</li> </ul> Note <p>This implementation is not deterministic if sort_labels is False. If sort_labels is True, then labels are sorted by index and result is deterministic, but it may tend to cases when all labels in the output will be the same, because nodes with low IDs will be preferred.</p> Source code in <code>ibisgraph/clustering/label_propagation.py</code> <pre><code>def label_propagation(\n    graph: IbisGraph,\n    max_iter: int = 30,\n    checkpoint_interval: int = 1,\n    sort_labels: bool = False,\n) -&gt; ibis.Table:\n    \"\"\"Perform Label Propagation clustering on a graph with Pregel.\n\n    Label Propagation is an iterative algorithm that assigns labels to nodes\n    based on the labels of their neighbors. Each node initially starts with\n    its own unique label and then iteratively adopts the most frequent label\n    among its neighbors.\n\n    Args:\n        graph: Input graph to perform clustering on.\n        max_iter: Maximum number of iterations. Defaults to 30.\n        checkpoint_interval: Interval for checkpointing. Defaults to 1.\n            Recommended to keep at 1 for single-node/in-memory backends.\n            For distributed engines like Apache Spark, larger values are recommended.\n        sort_labels: If True, sort labels before selecting mode. Defaults to False.\n\n    Returns:\n        A table with two columns:\n        - 'node_id': Original node identifiers\n        - 'label': Assigned cluster label for each node\n\n    Note:\n        This implementation is not deterministic if sort_labels is False.\n        If sort_labels is True, then labels are sorted by index and result is deterministic,\n        but it may tend to cases when all labels in the output will be the same,\n        because nodes with low IDs will be preferred.\n    \"\"\"\n    pregel = (\n        Pregel(graph)\n        .set_max_iter(max_iter)\n        .set_has_active_flag(True)\n        .set_checkpoint_interval(checkpoint_interval)\n        .set_filter_messages_from_non_active(False)\n        .set_stop_if_all_unactive(True)\n    )\n\n    pregel = pregel.add_vertex_col(\n        LABEL_COL_NAME,\n        ibis._[IbisGraphConstants.ID.value],\n        pregel.pregel_msg(),\n    ).set_active_flag_upd_col(pregel.pregel_msg() != ibis._[LABEL_COL_NAME])\n\n    pregel = pregel.add_message_to_dst(pregel.pregel_src(LABEL_COL_NAME))\n\n    if not graph.is_directed:\n        pregel = pregel.add_message_to_src(pregel.pregel_dst(LABEL_COL_NAME))\n\n    if sort_labels:\n        pregel = pregel.set_agg_expression_func(lambda msg: msg.collect().sort().modes())\n    else:\n        pregel = pregel.set_agg_expression_func(lambda msg: msg.collect().modes())\n    result = pregel.run()\n\n    return result.select(\n        result[IbisGraphConstants.ID.value].name(NODE_COL_NAME), result[LABEL_COL_NAME]\n    )\n</code></pre>"},{"location":"python/reference/ibisgraph/pregel/","title":"Index","text":""},{"location":"python/reference/ibisgraph/pregel/models/","title":"Models","text":""},{"location":"python/reference/ibisgraph/pregel/models/#ibisgraph.pregel.models.PregelConstants","title":"<code>PregelConstants</code>","text":"<p>               Bases: <code>Enum</code></p> Source code in <code>ibisgraph/pregel/models.py</code> <pre><code>class PregelConstants(Enum):\n    MSG_COL_NAME = \"_pregel_msg\"\n    ACTIVE_VERTEX_FLAG = \"_active_flag\"\n</code></pre>"},{"location":"python/reference/ibisgraph/pregel/models/#ibisgraph.pregel.models.PregelConstants.ACTIVE_VERTEX_FLAG","title":"<code>ACTIVE_VERTEX_FLAG = '_active_flag'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"python/reference/ibisgraph/pregel/models/#ibisgraph.pregel.models.PregelConstants.MSG_COL_NAME","title":"<code>MSG_COL_NAME = '_pregel_msg'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"python/reference/ibisgraph/pregel/models/#ibisgraph.pregel.models.PregelMessage","title":"<code>PregelMessage</code>  <code>dataclass</code>","text":"Source code in <code>ibisgraph/pregel/models.py</code> <pre><code>@dataclass\nclass PregelMessage:\n    target_column: Value\n    msg_expr: Value\n</code></pre>"},{"location":"python/reference/ibisgraph/pregel/models/#ibisgraph.pregel.models.PregelMessage.msg_expr","title":"<code>msg_expr</code>  <code>instance-attribute</code>","text":""},{"location":"python/reference/ibisgraph/pregel/models/#ibisgraph.pregel.models.PregelMessage.target_column","title":"<code>target_column</code>  <code>instance-attribute</code>","text":""},{"location":"python/reference/ibisgraph/pregel/models/#ibisgraph.pregel.models.PregelMessage.__init__","title":"<code>__init__(target_column, msg_expr)</code>","text":""},{"location":"python/reference/ibisgraph/pregel/models/#ibisgraph.pregel.models.PregelVertexColumn","title":"<code>PregelVertexColumn</code>  <code>dataclass</code>","text":"Source code in <code>ibisgraph/pregel/models.py</code> <pre><code>@dataclass\nclass PregelVertexColumn:\n    col_name: str\n    initial_expr: Value | Deferred\n    update_expr: Value | Deferred\n</code></pre>"},{"location":"python/reference/ibisgraph/pregel/models/#ibisgraph.pregel.models.PregelVertexColumn.col_name","title":"<code>col_name</code>  <code>instance-attribute</code>","text":""},{"location":"python/reference/ibisgraph/pregel/models/#ibisgraph.pregel.models.PregelVertexColumn.initial_expr","title":"<code>initial_expr</code>  <code>instance-attribute</code>","text":""},{"location":"python/reference/ibisgraph/pregel/models/#ibisgraph.pregel.models.PregelVertexColumn.update_expr","title":"<code>update_expr</code>  <code>instance-attribute</code>","text":""},{"location":"python/reference/ibisgraph/pregel/models/#ibisgraph.pregel.models.PregelVertexColumn.__init__","title":"<code>__init__(col_name, initial_expr, update_expr)</code>","text":""},{"location":"python/reference/ibisgraph/pregel/pregel/","title":"Pregel","text":""},{"location":"python/reference/ibisgraph/pregel/pregel/#ibisgraph.pregel.pregel.Pregel","title":"<code>Pregel</code>","text":"<p>A Pregel-style graph processing implementation using Ibis.</p> <p>This class provides a flexible framework for implementing vertex-centric graph algorithms with support for: - Vertex-level message passing - Customizable vertex column updates - Optional active vertex tracking - Early stopping - Custom activity expressions - Configurable maximum iterations - Checkpointing</p> <p>Key methods allow adding vertex columns, defining message passing strategies, and controlling algorithm execution parameters.</p> Note <p>This API is considered low-level. While it is public, it may be hard to use directly. It is recommended to use high-level APIs with routines already implemented with this Pregel.</p> Source code in <code>ibisgraph/pregel/pregel.py</code> <pre><code>class Pregel:\n    \"\"\"A Pregel-style graph processing implementation using Ibis.\n\n    This class provides a flexible framework for implementing vertex-centric graph algorithms\n    with support for:\n    - Vertex-level message passing\n    - Customizable vertex column updates\n    - Optional active vertex tracking\n    - Early stopping\n    - Custom activity expressions\n    - Configurable maximum iterations\n    - Checkpointing\n\n    Key methods allow adding vertex columns, defining message passing strategies,\n    and controlling algorithm execution parameters.\n\n    Note:\n        This API is considered low-level. While it is public, it may be hard to use directly.\n        It is recommended to use high-level APIs with routines already implemented with this Pregel.\n    \"\"\"\n\n    def __init__(self, graph: IbisGraph) -&gt; None:\n        \"\"\"Initialize a Pregel graph processing instance.\n\n        Args:\n            graph: An IbisGraph instance representing the graph to be processed.\n        \"\"\"\n        self._graph = graph\n        self._has_active_flag = False\n        self._initial_active_flag: ibis.Value | ibis.Deferred = ibis.literal(True)\n        self._vertex_cols: dict[str, PregelVertexColumn] = {}\n        self._messages: list[PregelMessage] = []\n        self._agg_expression_func: Callable[[ibis.Value], ibis.Value] | None = None\n        self._do_early_stopping = True\n        self._max_iter = 10\n        self._checkpoint_interval = 1\n        self._active_flag_upd_expr: ibis.Value | ibis.Deferred | None = None\n        self._filter_messages_from_non_active: bool = False\n        self._stop_if_all_non_active: bool = False\n\n    def pregel_src(self, col_name: str) -&gt; ibis.Value:\n        \"\"\"Helper method to access attributes of the source column in messages generation.\n\n        Args:\n            col_name: Name of the attribute.\n\n        Returns:\n            Ibis wrapper around the attribute.\n        \"\"\"\n        return getattr(ibis._, IbisGraphConstants.SRC.value)[col_name]\n\n    def pregel_dst(self, col_name: str) -&gt; ibis.Value:\n        \"\"\"Helper method to access attributes of the destination column in messages generation.\n\n        Args:\n            col_name: Name of the attribute.\n\n        Returns:\n            Ibis wrapper around the attribute.\n        \"\"\"\n        return getattr(ibis._, IbisGraphConstants.DST.value)[col_name]\n\n    def pregel_edge(self, col_name: str) -&gt; ibis.Value:\n        \"\"\"Helper method to access attributes of the edge in messages generation.\n\n        Args:\n            col_name: Name of the attribute.\n\n        Returns:\n            Ibis wrapper around the attribute.\n        \"\"\"\n        return getattr(ibis._, IbisGraphConstants.EDGE.value)[col_name]\n\n    def pregel_msg(self) -&gt; ibis.Value:\n        \"\"\"Helper method to access the Pregel message.\n\n        Returns:\n            Ibis wrapper around the message.\n        \"\"\"\n        return getattr(ibis._, PregelConstants.MSG_COL_NAME.value)\n\n    def add_vertex_col(\n        self,\n        col_name: str,\n        initial_expr: ibis.Value | ibis.Deferred,\n        update_expr: ibis.Value | ibis.Deferred,\n    ) -&gt; Self:\n        \"\"\"Add a vertex column to the Pregel.\n\n        Args:\n            col_name: Name of the column that will be part of the output.\n            initial_expr: Expression for the initial value of the column.\n            update_expr: Expression to update the column, may use pregel_msg.\n\n        Returns:\n            Updated instance of the Pregel.\n        \"\"\"\n        self._vertex_cols[col_name] = PregelVertexColumn(col_name, initial_expr, update_expr)\n        return self\n\n    def remove_vertex_col(self, col_name) -&gt; Self:\n        \"\"\"Delete an already added vertex column by name.\n\n        Args:\n            col_name: Name of the column to delete.\n\n        Returns:\n            Updated instance of the Pregel.\n            Does nothing if column does not exist.\n        \"\"\"\n        if col_name in self._vertex_cols:\n            self._vertex_cols.pop(col_name)\n\n        return self\n\n    def add_message_to_src(self, message: ibis.Value) -&gt; Self:\n        \"\"\"Add a message targeting the source of the edge.\n\n        Args:\n            message: Ibis expression for the message; can use src, dst and edge attributes.\n\n        Returns:\n            Updated instance of the Pregel.\n        \"\"\"\n        self._messages.append(PregelMessage(self.pregel_src(IbisGraphConstants.ID.value), message))\n        return self\n\n    def add_message_to_dst(self, message: ibis.Value) -&gt; Self:\n        \"\"\"Add a message targeting the destination of the edge.\n\n        Args:\n            message: Ibis expression for the message; can use src, dst and edge attributes.\n\n        Returns:\n            Updated instance of the Pregel.\n        \"\"\"\n        self._messages.append(PregelMessage(self.pregel_dst(IbisGraphConstants.ID.value), message))\n        return self\n\n    def set_has_active_flag(self, value: bool) -&gt; Self:\n        \"\"\"Set whether algorithm supports vertices voting to stop iterations.\n\n        Args:\n            value: Whether to enable active flag support.\n\n        Returns:\n            Updated instance of the Pregel.\n\n        Note:\n            If initial expression is not provided, \"literal(True)\" will be used,\n            meaning all vertices are initially active.\n        \"\"\"\n        self._has_active_flag = value\n        return self\n\n    def set_initial_active_flag(self, expression: ibis.Value | ibis.Deferred) -&gt; Self:\n        \"\"\"Set the expression for initial values of the active flag column.\n\n        Args:\n            expression: Ibis expression for the initial value of the active flag.\n\n        Returns:\n            Updated instance of the Pregel.\n            Automatically sets \"has_active_flag\" to True.\n        \"\"\"\n        self._has_active_flag = True\n        self._initial_active_flag = expression\n        return self\n\n    def set_agg_expression_func(self, expression: Callable[[ibis.Value], ibis.Value]) -&gt; Self:\n        \"\"\"Set the aggregation expression function for processing messages.\n\n        Args:\n            expression: A callable that takes an Ibis value (message column) and returns\n                an aggregated Ibis value. Common aggregations include sum, max, first, etc.\n\n        Returns:\n            Updated instance of the Pregel.\n        \"\"\"\n        self._agg_expression_func = expression\n        return self\n\n    def set_early_stopping(self, value: bool) -&gt; Self:\n        \"\"\"Set whether early stopping is enabled.\n\n        Early stopping allows termination before reaching maximum iterations if no new\n        messages are generated. This can optimize computation but has overhead for checking\n        message nullity. For algorithms with guaranteed non-null messages (e.g., LabelPropagation),\n        it's recommended to use other control methods (vertices voting, max iter, etc.).\n\n        Args:\n            value: Whether to enable early stopping.\n\n        Returns:\n            Updated instance of the Pregel.\n        \"\"\"\n        self._do_early_stopping = value\n        return self\n\n    def set_max_iter(self, value: int) -&gt; Self:\n        \"\"\"Set the maximum number of iterations.\n\n        Args:\n            value: Positive integer for maximum iterations.\n\n        Returns:\n            Updated instance of the Pregel.\n\n        Raises:\n            ValueError: If value is not positive.\n        \"\"\"\n        if value &lt;= 0:\n            raise ValueError(f\"Expected positive integer but got {value}.\")\n\n        self._max_iter = value\n        return self\n\n    def set_checkpoint_interval(self, value: int) -&gt; Self:\n        \"\"\"Set the interval for checkpointing during iterations.\n\n        For DuckDB and other single-node backends, checkpoint on each step works better.\n        For distributed engines like Apache Spark, larger values are recommended.\n\n        Args:\n            value: Number of iterations between checkpoints. 0 disables checkpointing.\n\n        Returns:\n            Updated instance of the Pregel.\n\n        Raises:\n            ValueError: If value is negative.\n        \"\"\"\n        if value &lt; 0:\n            raise ValueError(f\"Expected non-negative integer but got {value}.\")\n\n        self._checkpoint_interval = value\n        return self\n\n    def set_active_flag_upd_col(self, expression: ibis.Value | ibis.Deferred) -&gt; Self:\n        \"\"\"Set a custom update expression for the active flag column.\n\n        Args:\n            expression: Ibis expression defining how the active flag should be updated.\n                For example, in PageRank this expression should check if the difference\n                between old and new ranks is greater than tolerance.\n\n        Returns:\n            Updated instance of the Pregel.\n        \"\"\"\n        self._active_flag_upd_expr = expression\n        return self\n\n    def set_filter_messages_from_non_active(self, value: bool) -&gt; Self:\n        \"\"\"Set whether to filter out messages from non-active vertices.\n\n        Args:\n            value: Whether to enable message filtering.\n\n        Returns:\n            Updated instance of the Pregel.\n\n        Note:\n            This can break some algorithms! For example, in LabelPropagation,\n            if a vertex didn't change its label it's considered inactive,\n            but we should continue generating messages from it.\n        \"\"\"\n        self._filter_messages_from_non_active = value\n        return self\n\n    def set_stop_if_all_unactive(self, value: bool) -&gt; Self:\n        \"\"\"Set whether to stop early if all vertices become inactive.\n\n        Args:\n            value: Whether to enable stopping on all inactive.\n\n        Returns:\n            Updated instance of the Pregel.\n\n        Note:\n            Not all algorithms benefit from this feature! The check has overhead.\n        \"\"\"\n        self._stop_if_all_non_active = value\n        return self\n\n    def _validate(self) -&gt; None:\n        \"\"\"Validate Pregel configuration before running.\n\n        Raises:\n            ValueError: If required components are missing.\n        \"\"\"\n        if self._agg_expression_func is None:\n            raise ValueError(\"AggExpression should be provided!\")\n        if len(self._messages) == 0:\n            raise ValueError(\"At least one message (to src or to dst) should be provided!\")\n        if len(self._vertex_cols) == 0:\n            raise ValueError(\"At least one vertex column should be provided!\")\n\n    def run(self) -&gt; ibis.Table:\n        \"\"\"Run the Pregel algorithm and return results.\n\n        Returns:\n            Table with all existing vertices columns and all new columns.\n            If active flag was used, it is removed from the final result.\n\n        Raises:\n            ValueError: If validation fails before running.\n        \"\"\"\n        self._validate()\n        messages = [\n            ibis.struct({IbisGraphConstants.ID.value: m.target_column, \"msg\": m.msg_expr})\n            for m in self._messages\n        ]\n\n        graph_columns = [getattr(ibis._, c) for c in self._graph._nodes.columns]\n        for vcol in self._vertex_cols.values():\n            graph_columns.append(vcol.initial_expr.name(vcol.col_name))\n\n        if self._has_active_flag:\n            graph_columns.append(\n                self._initial_active_flag.name(PregelConstants.ACTIVE_VERTEX_FLAG.value)\n            )\n\n        pregel_nodes_data = self._graph._nodes.select(*graph_columns)\n        edges = self._graph._edges.select(\n            ibis.struct({col: getattr(ibis._, col) for col in self._graph._edges.columns}).name(\n                IbisGraphConstants.EDGE.value\n            )\n        ).cache()\n\n        it = 0\n\n        while it &lt; self._max_iter:\n            logger.info(f\"Start iteration {it} of {self._max_iter}\")\n            it += 1\n\n            src_nodes_data = pregel_nodes_data.select(\n                ibis.struct({col: ibis._[col] for col in pregel_nodes_data.columns}).name(\n                    IbisGraphConstants.SRC.value\n                )\n            )\n            dst_nodes_data = pregel_nodes_data.select(\n                ibis.struct({col: ibis._[col] for col in pregel_nodes_data.columns}).name(\n                    IbisGraphConstants.DST.value\n                )\n            )\n            triplets = src_nodes_data.inner_join(\n                edges,\n                [\n                    src_nodes_data[IbisGraphConstants.SRC.value][IbisGraphConstants.ID.value]\n                    == edges[IbisGraphConstants.EDGE.value][IbisGraphConstants.SRC.value]\n                ],\n            ).inner_join(\n                dst_nodes_data,\n                [\n                    dst_nodes_data[IbisGraphConstants.DST.value][IbisGraphConstants.ID.value]\n                    == edges[IbisGraphConstants.EDGE.value][IbisGraphConstants.DST.value]\n                ],\n            )\n            if self._filter_messages_from_non_active:\n                src_active = triplets[IbisGraphConstants.SRC.value][\n                    PregelConstants.ACTIVE_VERTEX_FLAG.value\n                ].cast(\"bool\")\n                dst_active = triplets[IbisGraphConstants.DST.value][\n                    PregelConstants.ACTIVE_VERTEX_FLAG.value\n                ].cast(\"bool\")\n                triplets = triplets.filter(ibis.or_(src_active, dst_active))\n\n            triplets_with_messages = triplets.select(ibis.array(messages).unnest().name(\"msg\"))\n            new_messages_table = triplets_with_messages.filter(\n                triplets_with_messages[\"msg\"][\"msg\"].notnull()\n            ).select(\n                triplets_with_messages[\"msg\"][IbisGraphConstants.ID.value],\n                triplets_with_messages[\"msg\"][\"msg\"].name(PregelConstants.MSG_COL_NAME.value),\n            )\n\n            if self._do_early_stopping:\n                cnt_of_not_null_msgs = new_messages_table.count().to_pandas()\n                logger.info(f\"{cnt_of_not_null_msgs} non null messages were generated.\")\n                if cnt_of_not_null_msgs == 0:\n                    logger.info(f\"Pregel stopped on the iteration {it}: no more messages.\")\n                    break\n\n            assert self._agg_expression_func is not None\n            msg_col = new_messages_table[PregelConstants.MSG_COL_NAME.value]\n            aggregated_messages = new_messages_table.group_by(IbisGraphConstants.ID.value).agg(\n                {PregelConstants.MSG_COL_NAME.value: self._agg_expression_func(msg_col)}\n            )\n\n            pregel_nodes_data = pregel_nodes_data.join(\n                aggregated_messages, [IbisGraphConstants.ID.value], how=\"left\"\n            )\n\n            new_columns = [getattr(pregel_nodes_data, col) for col in self._graph._nodes.columns]\n            for vertex_col in self._vertex_cols.values():\n                new_columns.append(vertex_col.update_expr.name(vertex_col.col_name))\n\n            if self._has_active_flag:\n                if self._active_flag_upd_expr is not None:\n                    new_active_col = self._active_flag_upd_expr.name(\n                        PregelConstants.ACTIVE_VERTEX_FLAG.value\n                    )\n                else:\n                    new_active_col = (\n                        pregel_nodes_data[PregelConstants.MSG_COL_NAME.value]\n                        .notnull()\n                        .name(PregelConstants.ACTIVE_VERTEX_FLAG.value)\n                    )\n                new_columns.append(new_active_col)\n\n            tmp_pregel_nodes_data = pregel_nodes_data.select(*new_columns)\n\n            if (\n                (self._checkpoint_interval &gt; 0)\n                and (it != 0)\n                and (it % self._checkpoint_interval == 0)\n            ):\n                pregel_nodes_data = tmp_pregel_nodes_data.cache()\n            else:\n                pregel_nodes_data = tmp_pregel_nodes_data\n\n            if self._stop_if_all_non_active:\n                all_active = (\n                    pregel_nodes_data.select(\n                        pregel_nodes_data[PregelConstants.ACTIVE_VERTEX_FLAG.value]\n                    )\n                    .distinct()\n                    .to_pandas()\n                )\n                if len(all_active) == 1:\n                    if not all_active.values[0]:\n                        logger.info(\"Pregel stopped earlier: all nodes are non-active.\")\n                        break\n\n        logger.info(\"Pregel stopped: max-iterations reached.\")\n        if self._has_active_flag:\n            return pregel_nodes_data.drop(PregelConstants.ACTIVE_VERTEX_FLAG.value)\n        else:\n            return pregel_nodes_data\n</code></pre>"},{"location":"python/reference/ibisgraph/pregel/pregel/#ibisgraph.pregel.pregel.Pregel.__init__","title":"<code>__init__(graph)</code>","text":"<p>Initialize a Pregel graph processing instance.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>IbisGraph</code> <p>An IbisGraph instance representing the graph to be processed.</p> required Source code in <code>ibisgraph/pregel/pregel.py</code> <pre><code>def __init__(self, graph: IbisGraph) -&gt; None:\n    \"\"\"Initialize a Pregel graph processing instance.\n\n    Args:\n        graph: An IbisGraph instance representing the graph to be processed.\n    \"\"\"\n    self._graph = graph\n    self._has_active_flag = False\n    self._initial_active_flag: ibis.Value | ibis.Deferred = ibis.literal(True)\n    self._vertex_cols: dict[str, PregelVertexColumn] = {}\n    self._messages: list[PregelMessage] = []\n    self._agg_expression_func: Callable[[ibis.Value], ibis.Value] | None = None\n    self._do_early_stopping = True\n    self._max_iter = 10\n    self._checkpoint_interval = 1\n    self._active_flag_upd_expr: ibis.Value | ibis.Deferred | None = None\n    self._filter_messages_from_non_active: bool = False\n    self._stop_if_all_non_active: bool = False\n</code></pre>"},{"location":"python/reference/ibisgraph/pregel/pregel/#ibisgraph.pregel.pregel.Pregel.add_message_to_dst","title":"<code>add_message_to_dst(message)</code>","text":"<p>Add a message targeting the destination of the edge.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>Value</code> <p>Ibis expression for the message; can use src, dst and edge attributes.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>Updated instance of the Pregel.</p> Source code in <code>ibisgraph/pregel/pregel.py</code> <pre><code>def add_message_to_dst(self, message: ibis.Value) -&gt; Self:\n    \"\"\"Add a message targeting the destination of the edge.\n\n    Args:\n        message: Ibis expression for the message; can use src, dst and edge attributes.\n\n    Returns:\n        Updated instance of the Pregel.\n    \"\"\"\n    self._messages.append(PregelMessage(self.pregel_dst(IbisGraphConstants.ID.value), message))\n    return self\n</code></pre>"},{"location":"python/reference/ibisgraph/pregel/pregel/#ibisgraph.pregel.pregel.Pregel.add_message_to_src","title":"<code>add_message_to_src(message)</code>","text":"<p>Add a message targeting the source of the edge.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>Value</code> <p>Ibis expression for the message; can use src, dst and edge attributes.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>Updated instance of the Pregel.</p> Source code in <code>ibisgraph/pregel/pregel.py</code> <pre><code>def add_message_to_src(self, message: ibis.Value) -&gt; Self:\n    \"\"\"Add a message targeting the source of the edge.\n\n    Args:\n        message: Ibis expression for the message; can use src, dst and edge attributes.\n\n    Returns:\n        Updated instance of the Pregel.\n    \"\"\"\n    self._messages.append(PregelMessage(self.pregel_src(IbisGraphConstants.ID.value), message))\n    return self\n</code></pre>"},{"location":"python/reference/ibisgraph/pregel/pregel/#ibisgraph.pregel.pregel.Pregel.add_vertex_col","title":"<code>add_vertex_col(col_name, initial_expr, update_expr)</code>","text":"<p>Add a vertex column to the Pregel.</p> <p>Parameters:</p> Name Type Description Default <code>col_name</code> <code>str</code> <p>Name of the column that will be part of the output.</p> required <code>initial_expr</code> <code>Value | Deferred</code> <p>Expression for the initial value of the column.</p> required <code>update_expr</code> <code>Value | Deferred</code> <p>Expression to update the column, may use pregel_msg.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>Updated instance of the Pregel.</p> Source code in <code>ibisgraph/pregel/pregel.py</code> <pre><code>def add_vertex_col(\n    self,\n    col_name: str,\n    initial_expr: ibis.Value | ibis.Deferred,\n    update_expr: ibis.Value | ibis.Deferred,\n) -&gt; Self:\n    \"\"\"Add a vertex column to the Pregel.\n\n    Args:\n        col_name: Name of the column that will be part of the output.\n        initial_expr: Expression for the initial value of the column.\n        update_expr: Expression to update the column, may use pregel_msg.\n\n    Returns:\n        Updated instance of the Pregel.\n    \"\"\"\n    self._vertex_cols[col_name] = PregelVertexColumn(col_name, initial_expr, update_expr)\n    return self\n</code></pre>"},{"location":"python/reference/ibisgraph/pregel/pregel/#ibisgraph.pregel.pregel.Pregel.pregel_dst","title":"<code>pregel_dst(col_name)</code>","text":"<p>Helper method to access attributes of the destination column in messages generation.</p> <p>Parameters:</p> Name Type Description Default <code>col_name</code> <code>str</code> <p>Name of the attribute.</p> required <p>Returns:</p> Type Description <code>Value</code> <p>Ibis wrapper around the attribute.</p> Source code in <code>ibisgraph/pregel/pregel.py</code> <pre><code>def pregel_dst(self, col_name: str) -&gt; ibis.Value:\n    \"\"\"Helper method to access attributes of the destination column in messages generation.\n\n    Args:\n        col_name: Name of the attribute.\n\n    Returns:\n        Ibis wrapper around the attribute.\n    \"\"\"\n    return getattr(ibis._, IbisGraphConstants.DST.value)[col_name]\n</code></pre>"},{"location":"python/reference/ibisgraph/pregel/pregel/#ibisgraph.pregel.pregel.Pregel.pregel_edge","title":"<code>pregel_edge(col_name)</code>","text":"<p>Helper method to access attributes of the edge in messages generation.</p> <p>Parameters:</p> Name Type Description Default <code>col_name</code> <code>str</code> <p>Name of the attribute.</p> required <p>Returns:</p> Type Description <code>Value</code> <p>Ibis wrapper around the attribute.</p> Source code in <code>ibisgraph/pregel/pregel.py</code> <pre><code>def pregel_edge(self, col_name: str) -&gt; ibis.Value:\n    \"\"\"Helper method to access attributes of the edge in messages generation.\n\n    Args:\n        col_name: Name of the attribute.\n\n    Returns:\n        Ibis wrapper around the attribute.\n    \"\"\"\n    return getattr(ibis._, IbisGraphConstants.EDGE.value)[col_name]\n</code></pre>"},{"location":"python/reference/ibisgraph/pregel/pregel/#ibisgraph.pregel.pregel.Pregel.pregel_msg","title":"<code>pregel_msg()</code>","text":"<p>Helper method to access the Pregel message.</p> <p>Returns:</p> Type Description <code>Value</code> <p>Ibis wrapper around the message.</p> Source code in <code>ibisgraph/pregel/pregel.py</code> <pre><code>def pregel_msg(self) -&gt; ibis.Value:\n    \"\"\"Helper method to access the Pregel message.\n\n    Returns:\n        Ibis wrapper around the message.\n    \"\"\"\n    return getattr(ibis._, PregelConstants.MSG_COL_NAME.value)\n</code></pre>"},{"location":"python/reference/ibisgraph/pregel/pregel/#ibisgraph.pregel.pregel.Pregel.pregel_src","title":"<code>pregel_src(col_name)</code>","text":"<p>Helper method to access attributes of the source column in messages generation.</p> <p>Parameters:</p> Name Type Description Default <code>col_name</code> <code>str</code> <p>Name of the attribute.</p> required <p>Returns:</p> Type Description <code>Value</code> <p>Ibis wrapper around the attribute.</p> Source code in <code>ibisgraph/pregel/pregel.py</code> <pre><code>def pregel_src(self, col_name: str) -&gt; ibis.Value:\n    \"\"\"Helper method to access attributes of the source column in messages generation.\n\n    Args:\n        col_name: Name of the attribute.\n\n    Returns:\n        Ibis wrapper around the attribute.\n    \"\"\"\n    return getattr(ibis._, IbisGraphConstants.SRC.value)[col_name]\n</code></pre>"},{"location":"python/reference/ibisgraph/pregel/pregel/#ibisgraph.pregel.pregel.Pregel.remove_vertex_col","title":"<code>remove_vertex_col(col_name)</code>","text":"<p>Delete an already added vertex column by name.</p> <p>Parameters:</p> Name Type Description Default <code>col_name</code> <p>Name of the column to delete.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>Updated instance of the Pregel.</p> <code>Self</code> <p>Does nothing if column does not exist.</p> Source code in <code>ibisgraph/pregel/pregel.py</code> <pre><code>def remove_vertex_col(self, col_name) -&gt; Self:\n    \"\"\"Delete an already added vertex column by name.\n\n    Args:\n        col_name: Name of the column to delete.\n\n    Returns:\n        Updated instance of the Pregel.\n        Does nothing if column does not exist.\n    \"\"\"\n    if col_name in self._vertex_cols:\n        self._vertex_cols.pop(col_name)\n\n    return self\n</code></pre>"},{"location":"python/reference/ibisgraph/pregel/pregel/#ibisgraph.pregel.pregel.Pregel.run","title":"<code>run()</code>","text":"<p>Run the Pregel algorithm and return results.</p> <p>Returns:</p> Type Description <code>Table</code> <p>Table with all existing vertices columns and all new columns.</p> <code>Table</code> <p>If active flag was used, it is removed from the final result.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If validation fails before running.</p> Source code in <code>ibisgraph/pregel/pregel.py</code> <pre><code>def run(self) -&gt; ibis.Table:\n    \"\"\"Run the Pregel algorithm and return results.\n\n    Returns:\n        Table with all existing vertices columns and all new columns.\n        If active flag was used, it is removed from the final result.\n\n    Raises:\n        ValueError: If validation fails before running.\n    \"\"\"\n    self._validate()\n    messages = [\n        ibis.struct({IbisGraphConstants.ID.value: m.target_column, \"msg\": m.msg_expr})\n        for m in self._messages\n    ]\n\n    graph_columns = [getattr(ibis._, c) for c in self._graph._nodes.columns]\n    for vcol in self._vertex_cols.values():\n        graph_columns.append(vcol.initial_expr.name(vcol.col_name))\n\n    if self._has_active_flag:\n        graph_columns.append(\n            self._initial_active_flag.name(PregelConstants.ACTIVE_VERTEX_FLAG.value)\n        )\n\n    pregel_nodes_data = self._graph._nodes.select(*graph_columns)\n    edges = self._graph._edges.select(\n        ibis.struct({col: getattr(ibis._, col) for col in self._graph._edges.columns}).name(\n            IbisGraphConstants.EDGE.value\n        )\n    ).cache()\n\n    it = 0\n\n    while it &lt; self._max_iter:\n        logger.info(f\"Start iteration {it} of {self._max_iter}\")\n        it += 1\n\n        src_nodes_data = pregel_nodes_data.select(\n            ibis.struct({col: ibis._[col] for col in pregel_nodes_data.columns}).name(\n                IbisGraphConstants.SRC.value\n            )\n        )\n        dst_nodes_data = pregel_nodes_data.select(\n            ibis.struct({col: ibis._[col] for col in pregel_nodes_data.columns}).name(\n                IbisGraphConstants.DST.value\n            )\n        )\n        triplets = src_nodes_data.inner_join(\n            edges,\n            [\n                src_nodes_data[IbisGraphConstants.SRC.value][IbisGraphConstants.ID.value]\n                == edges[IbisGraphConstants.EDGE.value][IbisGraphConstants.SRC.value]\n            ],\n        ).inner_join(\n            dst_nodes_data,\n            [\n                dst_nodes_data[IbisGraphConstants.DST.value][IbisGraphConstants.ID.value]\n                == edges[IbisGraphConstants.EDGE.value][IbisGraphConstants.DST.value]\n            ],\n        )\n        if self._filter_messages_from_non_active:\n            src_active = triplets[IbisGraphConstants.SRC.value][\n                PregelConstants.ACTIVE_VERTEX_FLAG.value\n            ].cast(\"bool\")\n            dst_active = triplets[IbisGraphConstants.DST.value][\n                PregelConstants.ACTIVE_VERTEX_FLAG.value\n            ].cast(\"bool\")\n            triplets = triplets.filter(ibis.or_(src_active, dst_active))\n\n        triplets_with_messages = triplets.select(ibis.array(messages).unnest().name(\"msg\"))\n        new_messages_table = triplets_with_messages.filter(\n            triplets_with_messages[\"msg\"][\"msg\"].notnull()\n        ).select(\n            triplets_with_messages[\"msg\"][IbisGraphConstants.ID.value],\n            triplets_with_messages[\"msg\"][\"msg\"].name(PregelConstants.MSG_COL_NAME.value),\n        )\n\n        if self._do_early_stopping:\n            cnt_of_not_null_msgs = new_messages_table.count().to_pandas()\n            logger.info(f\"{cnt_of_not_null_msgs} non null messages were generated.\")\n            if cnt_of_not_null_msgs == 0:\n                logger.info(f\"Pregel stopped on the iteration {it}: no more messages.\")\n                break\n\n        assert self._agg_expression_func is not None\n        msg_col = new_messages_table[PregelConstants.MSG_COL_NAME.value]\n        aggregated_messages = new_messages_table.group_by(IbisGraphConstants.ID.value).agg(\n            {PregelConstants.MSG_COL_NAME.value: self._agg_expression_func(msg_col)}\n        )\n\n        pregel_nodes_data = pregel_nodes_data.join(\n            aggregated_messages, [IbisGraphConstants.ID.value], how=\"left\"\n        )\n\n        new_columns = [getattr(pregel_nodes_data, col) for col in self._graph._nodes.columns]\n        for vertex_col in self._vertex_cols.values():\n            new_columns.append(vertex_col.update_expr.name(vertex_col.col_name))\n\n        if self._has_active_flag:\n            if self._active_flag_upd_expr is not None:\n                new_active_col = self._active_flag_upd_expr.name(\n                    PregelConstants.ACTIVE_VERTEX_FLAG.value\n                )\n            else:\n                new_active_col = (\n                    pregel_nodes_data[PregelConstants.MSG_COL_NAME.value]\n                    .notnull()\n                    .name(PregelConstants.ACTIVE_VERTEX_FLAG.value)\n                )\n            new_columns.append(new_active_col)\n\n        tmp_pregel_nodes_data = pregel_nodes_data.select(*new_columns)\n\n        if (\n            (self._checkpoint_interval &gt; 0)\n            and (it != 0)\n            and (it % self._checkpoint_interval == 0)\n        ):\n            pregel_nodes_data = tmp_pregel_nodes_data.cache()\n        else:\n            pregel_nodes_data = tmp_pregel_nodes_data\n\n        if self._stop_if_all_non_active:\n            all_active = (\n                pregel_nodes_data.select(\n                    pregel_nodes_data[PregelConstants.ACTIVE_VERTEX_FLAG.value]\n                )\n                .distinct()\n                .to_pandas()\n            )\n            if len(all_active) == 1:\n                if not all_active.values[0]:\n                    logger.info(\"Pregel stopped earlier: all nodes are non-active.\")\n                    break\n\n    logger.info(\"Pregel stopped: max-iterations reached.\")\n    if self._has_active_flag:\n        return pregel_nodes_data.drop(PregelConstants.ACTIVE_VERTEX_FLAG.value)\n    else:\n        return pregel_nodes_data\n</code></pre>"},{"location":"python/reference/ibisgraph/pregel/pregel/#ibisgraph.pregel.pregel.Pregel.set_active_flag_upd_col","title":"<code>set_active_flag_upd_col(expression)</code>","text":"<p>Set a custom update expression for the active flag column.</p> <p>Parameters:</p> Name Type Description Default <code>expression</code> <code>Value | Deferred</code> <p>Ibis expression defining how the active flag should be updated. For example, in PageRank this expression should check if the difference between old and new ranks is greater than tolerance.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>Updated instance of the Pregel.</p> Source code in <code>ibisgraph/pregel/pregel.py</code> <pre><code>def set_active_flag_upd_col(self, expression: ibis.Value | ibis.Deferred) -&gt; Self:\n    \"\"\"Set a custom update expression for the active flag column.\n\n    Args:\n        expression: Ibis expression defining how the active flag should be updated.\n            For example, in PageRank this expression should check if the difference\n            between old and new ranks is greater than tolerance.\n\n    Returns:\n        Updated instance of the Pregel.\n    \"\"\"\n    self._active_flag_upd_expr = expression\n    return self\n</code></pre>"},{"location":"python/reference/ibisgraph/pregel/pregel/#ibisgraph.pregel.pregel.Pregel.set_agg_expression_func","title":"<code>set_agg_expression_func(expression)</code>","text":"<p>Set the aggregation expression function for processing messages.</p> <p>Parameters:</p> Name Type Description Default <code>expression</code> <code>Callable[[Value], Value]</code> <p>A callable that takes an Ibis value (message column) and returns an aggregated Ibis value. Common aggregations include sum, max, first, etc.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>Updated instance of the Pregel.</p> Source code in <code>ibisgraph/pregel/pregel.py</code> <pre><code>def set_agg_expression_func(self, expression: Callable[[ibis.Value], ibis.Value]) -&gt; Self:\n    \"\"\"Set the aggregation expression function for processing messages.\n\n    Args:\n        expression: A callable that takes an Ibis value (message column) and returns\n            an aggregated Ibis value. Common aggregations include sum, max, first, etc.\n\n    Returns:\n        Updated instance of the Pregel.\n    \"\"\"\n    self._agg_expression_func = expression\n    return self\n</code></pre>"},{"location":"python/reference/ibisgraph/pregel/pregel/#ibisgraph.pregel.pregel.Pregel.set_checkpoint_interval","title":"<code>set_checkpoint_interval(value)</code>","text":"<p>Set the interval for checkpointing during iterations.</p> <p>For DuckDB and other single-node backends, checkpoint on each step works better. For distributed engines like Apache Spark, larger values are recommended.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>Number of iterations between checkpoints. 0 disables checkpointing.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>Updated instance of the Pregel.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If value is negative.</p> Source code in <code>ibisgraph/pregel/pregel.py</code> <pre><code>def set_checkpoint_interval(self, value: int) -&gt; Self:\n    \"\"\"Set the interval for checkpointing during iterations.\n\n    For DuckDB and other single-node backends, checkpoint on each step works better.\n    For distributed engines like Apache Spark, larger values are recommended.\n\n    Args:\n        value: Number of iterations between checkpoints. 0 disables checkpointing.\n\n    Returns:\n        Updated instance of the Pregel.\n\n    Raises:\n        ValueError: If value is negative.\n    \"\"\"\n    if value &lt; 0:\n        raise ValueError(f\"Expected non-negative integer but got {value}.\")\n\n    self._checkpoint_interval = value\n    return self\n</code></pre>"},{"location":"python/reference/ibisgraph/pregel/pregel/#ibisgraph.pregel.pregel.Pregel.set_early_stopping","title":"<code>set_early_stopping(value)</code>","text":"<p>Set whether early stopping is enabled.</p> <p>Early stopping allows termination before reaching maximum iterations if no new messages are generated. This can optimize computation but has overhead for checking message nullity. For algorithms with guaranteed non-null messages (e.g., LabelPropagation), it's recommended to use other control methods (vertices voting, max iter, etc.).</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>bool</code> <p>Whether to enable early stopping.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>Updated instance of the Pregel.</p> Source code in <code>ibisgraph/pregel/pregel.py</code> <pre><code>def set_early_stopping(self, value: bool) -&gt; Self:\n    \"\"\"Set whether early stopping is enabled.\n\n    Early stopping allows termination before reaching maximum iterations if no new\n    messages are generated. This can optimize computation but has overhead for checking\n    message nullity. For algorithms with guaranteed non-null messages (e.g., LabelPropagation),\n    it's recommended to use other control methods (vertices voting, max iter, etc.).\n\n    Args:\n        value: Whether to enable early stopping.\n\n    Returns:\n        Updated instance of the Pregel.\n    \"\"\"\n    self._do_early_stopping = value\n    return self\n</code></pre>"},{"location":"python/reference/ibisgraph/pregel/pregel/#ibisgraph.pregel.pregel.Pregel.set_filter_messages_from_non_active","title":"<code>set_filter_messages_from_non_active(value)</code>","text":"<p>Set whether to filter out messages from non-active vertices.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>bool</code> <p>Whether to enable message filtering.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>Updated instance of the Pregel.</p> Note <p>This can break some algorithms! For example, in LabelPropagation, if a vertex didn't change its label it's considered inactive, but we should continue generating messages from it.</p> Source code in <code>ibisgraph/pregel/pregel.py</code> <pre><code>def set_filter_messages_from_non_active(self, value: bool) -&gt; Self:\n    \"\"\"Set whether to filter out messages from non-active vertices.\n\n    Args:\n        value: Whether to enable message filtering.\n\n    Returns:\n        Updated instance of the Pregel.\n\n    Note:\n        This can break some algorithms! For example, in LabelPropagation,\n        if a vertex didn't change its label it's considered inactive,\n        but we should continue generating messages from it.\n    \"\"\"\n    self._filter_messages_from_non_active = value\n    return self\n</code></pre>"},{"location":"python/reference/ibisgraph/pregel/pregel/#ibisgraph.pregel.pregel.Pregel.set_has_active_flag","title":"<code>set_has_active_flag(value)</code>","text":"<p>Set whether algorithm supports vertices voting to stop iterations.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>bool</code> <p>Whether to enable active flag support.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>Updated instance of the Pregel.</p> Note <p>If initial expression is not provided, \"literal(True)\" will be used, meaning all vertices are initially active.</p> Source code in <code>ibisgraph/pregel/pregel.py</code> <pre><code>def set_has_active_flag(self, value: bool) -&gt; Self:\n    \"\"\"Set whether algorithm supports vertices voting to stop iterations.\n\n    Args:\n        value: Whether to enable active flag support.\n\n    Returns:\n        Updated instance of the Pregel.\n\n    Note:\n        If initial expression is not provided, \"literal(True)\" will be used,\n        meaning all vertices are initially active.\n    \"\"\"\n    self._has_active_flag = value\n    return self\n</code></pre>"},{"location":"python/reference/ibisgraph/pregel/pregel/#ibisgraph.pregel.pregel.Pregel.set_initial_active_flag","title":"<code>set_initial_active_flag(expression)</code>","text":"<p>Set the expression for initial values of the active flag column.</p> <p>Parameters:</p> Name Type Description Default <code>expression</code> <code>Value | Deferred</code> <p>Ibis expression for the initial value of the active flag.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>Updated instance of the Pregel.</p> <code>Self</code> <p>Automatically sets \"has_active_flag\" to True.</p> Source code in <code>ibisgraph/pregel/pregel.py</code> <pre><code>def set_initial_active_flag(self, expression: ibis.Value | ibis.Deferred) -&gt; Self:\n    \"\"\"Set the expression for initial values of the active flag column.\n\n    Args:\n        expression: Ibis expression for the initial value of the active flag.\n\n    Returns:\n        Updated instance of the Pregel.\n        Automatically sets \"has_active_flag\" to True.\n    \"\"\"\n    self._has_active_flag = True\n    self._initial_active_flag = expression\n    return self\n</code></pre>"},{"location":"python/reference/ibisgraph/pregel/pregel/#ibisgraph.pregel.pregel.Pregel.set_max_iter","title":"<code>set_max_iter(value)</code>","text":"<p>Set the maximum number of iterations.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>Positive integer for maximum iterations.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>Updated instance of the Pregel.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If value is not positive.</p> Source code in <code>ibisgraph/pregel/pregel.py</code> <pre><code>def set_max_iter(self, value: int) -&gt; Self:\n    \"\"\"Set the maximum number of iterations.\n\n    Args:\n        value: Positive integer for maximum iterations.\n\n    Returns:\n        Updated instance of the Pregel.\n\n    Raises:\n        ValueError: If value is not positive.\n    \"\"\"\n    if value &lt;= 0:\n        raise ValueError(f\"Expected positive integer but got {value}.\")\n\n    self._max_iter = value\n    return self\n</code></pre>"},{"location":"python/reference/ibisgraph/pregel/pregel/#ibisgraph.pregel.pregel.Pregel.set_stop_if_all_unactive","title":"<code>set_stop_if_all_unactive(value)</code>","text":"<p>Set whether to stop early if all vertices become inactive.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>bool</code> <p>Whether to enable stopping on all inactive.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>Updated instance of the Pregel.</p> Note <p>Not all algorithms benefit from this feature! The check has overhead.</p> Source code in <code>ibisgraph/pregel/pregel.py</code> <pre><code>def set_stop_if_all_unactive(self, value: bool) -&gt; Self:\n    \"\"\"Set whether to stop early if all vertices become inactive.\n\n    Args:\n        value: Whether to enable stopping on all inactive.\n\n    Returns:\n        Updated instance of the Pregel.\n\n    Note:\n        Not all algorithms benefit from this feature! The check has overhead.\n    \"\"\"\n    self._stop_if_all_non_active = value\n    return self\n</code></pre>"},{"location":"python/reference/ibisgraph/similarity/","title":"Index","text":""},{"location":"python/reference/ibisgraph/similarity/#ibisgraph.similarity.__all__","title":"<code>__all__ = ['jaccard_similarity']</code>  <code>module-attribute</code>","text":""},{"location":"python/reference/ibisgraph/similarity/#ibisgraph.similarity.jaccard_similarity","title":"<code>jaccard_similarity(graph)</code>","text":"<p>Calculate Jaccard similarity between all pairs of nodes in a graph.</p> <p>Jaccard similarity is defined as the size of the intersection of two nodes' neighborhoods divided by the size of their union. This function computes pairwise Jaccard similarities for all nodes in the graph.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>IbisGraph</code> <p>The input graph to compute Jaccard similarities on.</p> required <p>Returns:</p> Type Description <code>Table</code> <p>A table with three columns:</p> <code>Table</code> <ul> <li>\"node_id_left\": The first node in the pair</li> </ul> <code>Table</code> <ul> <li>\"node_id_right\": The second node in the pair</li> </ul> <code>Table</code> <ul> <li>\"jaccard_similarity\": The Jaccard similarity between the two nodes' neighborhoods</li> </ul> Note <p>For undirected graphs, the edge list is symmetrized to ensure correct neighborhood calculation.</p> Source code in <code>ibisgraph/similarity/similarity.py</code> <pre><code>def jaccard_similarity(graph: IbisGraph) -&gt; ibis.Table:\n    \"\"\"Calculate Jaccard similarity between all pairs of nodes in a graph.\n\n    Jaccard similarity is defined as the size of the intersection of two nodes' neighborhoods\n    divided by the size of their union. This function computes pairwise Jaccard similarities\n    for all nodes in the graph.\n\n    Args:\n        graph: The input graph to compute Jaccard similarities on.\n\n    Returns:\n        A table with three columns:\n        - \"node_id_left\": The first node in the pair\n        - \"node_id_right\": The second node in the pair\n        - \"jaccard_similarity\": The Jaccard similarity between the two nodes' neighborhoods\n\n    Note:\n        For undirected graphs, the edge list is symmetrized to ensure correct\n        neighborhood calculation.\n    \"\"\"\n    edges = graph.edges\n    if not graph.is_directed:\n        edges = edges.union(\n            edges.select(\n                edges[IbisGraphConstants.DST.value].name(IbisGraphConstants.SRC.value),\n                edges[IbisGraphConstants.SRC.value].name(IbisGraphConstants.DST.value),\n            )\n        )\n    neighbors = edges.group_by(\n        edges[IbisGraphConstants.SRC.value].name(IbisGraphConstants.ID.value)\n    ).aggregate(ibis._[IbisGraphConstants.DST.value].collect().name(\"nbr\"))\n\n    cross_joined = neighbors.cross_join(neighbors)\n    return cross_joined.select(\n        cross_joined[IbisGraphConstants.ID.value].name(\"node_id_left\"),\n        cross_joined[f\"{IbisGraphConstants.ID.value}_right\"].name(\"node_id_right\"),\n        (\n            (cross_joined[\"nbr\"].intersect(cross_joined[\"nbr_right\"])).length()\n            / (cross_joined[\"nbr\"].union(cross_joined[\"nbr_right\"]).length())\n        ).name(\"jaccard_similarity\"),\n    )\n</code></pre>"},{"location":"python/reference/ibisgraph/similarity/similarity/","title":"Similarity","text":""},{"location":"python/reference/ibisgraph/similarity/similarity/#ibisgraph.similarity.similarity.jaccard_similarity","title":"<code>jaccard_similarity(graph)</code>","text":"<p>Calculate Jaccard similarity between all pairs of nodes in a graph.</p> <p>Jaccard similarity is defined as the size of the intersection of two nodes' neighborhoods divided by the size of their union. This function computes pairwise Jaccard similarities for all nodes in the graph.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>IbisGraph</code> <p>The input graph to compute Jaccard similarities on.</p> required <p>Returns:</p> Type Description <code>Table</code> <p>A table with three columns:</p> <code>Table</code> <ul> <li>\"node_id_left\": The first node in the pair</li> </ul> <code>Table</code> <ul> <li>\"node_id_right\": The second node in the pair</li> </ul> <code>Table</code> <ul> <li>\"jaccard_similarity\": The Jaccard similarity between the two nodes' neighborhoods</li> </ul> Note <p>For undirected graphs, the edge list is symmetrized to ensure correct neighborhood calculation.</p> Source code in <code>ibisgraph/similarity/similarity.py</code> <pre><code>def jaccard_similarity(graph: IbisGraph) -&gt; ibis.Table:\n    \"\"\"Calculate Jaccard similarity between all pairs of nodes in a graph.\n\n    Jaccard similarity is defined as the size of the intersection of two nodes' neighborhoods\n    divided by the size of their union. This function computes pairwise Jaccard similarities\n    for all nodes in the graph.\n\n    Args:\n        graph: The input graph to compute Jaccard similarities on.\n\n    Returns:\n        A table with three columns:\n        - \"node_id_left\": The first node in the pair\n        - \"node_id_right\": The second node in the pair\n        - \"jaccard_similarity\": The Jaccard similarity between the two nodes' neighborhoods\n\n    Note:\n        For undirected graphs, the edge list is symmetrized to ensure correct\n        neighborhood calculation.\n    \"\"\"\n    edges = graph.edges\n    if not graph.is_directed:\n        edges = edges.union(\n            edges.select(\n                edges[IbisGraphConstants.DST.value].name(IbisGraphConstants.SRC.value),\n                edges[IbisGraphConstants.SRC.value].name(IbisGraphConstants.DST.value),\n            )\n        )\n    neighbors = edges.group_by(\n        edges[IbisGraphConstants.SRC.value].name(IbisGraphConstants.ID.value)\n    ).aggregate(ibis._[IbisGraphConstants.DST.value].collect().name(\"nbr\"))\n\n    cross_joined = neighbors.cross_join(neighbors)\n    return cross_joined.select(\n        cross_joined[IbisGraphConstants.ID.value].name(\"node_id_left\"),\n        cross_joined[f\"{IbisGraphConstants.ID.value}_right\"].name(\"node_id_right\"),\n        (\n            (cross_joined[\"nbr\"].intersect(cross_joined[\"nbr_right\"])).length()\n            / (cross_joined[\"nbr\"].union(cross_joined[\"nbr_right\"]).length())\n        ).name(\"jaccard_similarity\"),\n    )\n</code></pre>"},{"location":"python/reference/ibisgraph/traversal/","title":"Index","text":""},{"location":"python/reference/ibisgraph/traversal/#ibisgraph.traversal.__all__","title":"<code>__all__ = ['shortest_paths']</code>  <code>module-attribute</code>","text":""},{"location":"python/reference/ibisgraph/traversal/shortest_paths/","title":"Shortest paths","text":""},{"location":"python/reference/ibisgraph/traversal/shortest_paths/#ibisgraph.traversal.shortest_paths.DISTANCE_COL_NAME","title":"<code>DISTANCE_COL_NAME = 'distances'</code>  <code>module-attribute</code>","text":""},{"location":"python/reference/ibisgraph/traversal/shortest_paths/#ibisgraph.traversal.shortest_paths.SP_NODE_ID_COL_NAME","title":"<code>SP_NODE_ID_COL_NAME = 'node_id'</code>  <code>module-attribute</code>","text":""},{"location":"python/reference/ibisgraph/traversal/shortest_paths/#ibisgraph.traversal.shortest_paths.shortest_paths","title":"<code>shortest_paths(graph, landmarks, checkpoint_interval=1, max_iter=20)</code>","text":"<p>Calculate shortest paths from multiple landmark nodes in a graph using Pregel.</p> <p>Computes the shortest distances from specified landmark nodes to all other nodes in the graph using a Pregel-based algorithm. Supports both directed and undirected graphs.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>IbisGraph</code> <p>The input graph to compute shortest paths on.</p> required <code>landmarks</code> <code>Sequence[int]</code> <p>Sequence of node IDs to use as landmark/source nodes.</p> required <code>checkpoint_interval</code> <code>int</code> <p>Interval for checkpointing. Defaults to 1. Recommended to keep at 1 for single-node/in-memory backends. For distributed engines like Apache Spark, larger values are recommended.</p> <code>1</code> <code>max_iter</code> <code>int</code> <p>Maximum number of Pregel iterations. Acts as a safeguard against infinite iterations. Defaults to 20.</p> <code>20</code> <p>Returns:</p> Type Description <code>Table</code> <p>A table with two columns:</p> <code>Table</code> <ul> <li>\"node_id\": The ID of each node in the graph</li> </ul> <code>Table</code> <ul> <li>\"distances\": A struct containing shortest distances to each landmark node (distance_to_{landmark_id} -&gt; distance (int))</li> </ul> Warning <p>Distances to landmarks are handled as columns internally. If landmarks contains many elements, there may be performance issues due to operations on very wide tables.</p> Source code in <code>ibisgraph/traversal/shortest_paths.py</code> <pre><code>def shortest_paths(\n    graph: IbisGraph,\n    landmarks: Sequence[int],\n    checkpoint_interval: int = 1,\n    max_iter: int = 20,\n) -&gt; ibis.Table:\n    \"\"\"Calculate shortest paths from multiple landmark nodes in a graph using Pregel.\n\n    Computes the shortest distances from specified landmark nodes to all other\n    nodes in the graph using a Pregel-based algorithm. Supports both directed and\n    undirected graphs.\n\n    Args:\n        graph: The input graph to compute shortest paths on.\n        landmarks: Sequence of node IDs to use as landmark/source nodes.\n        checkpoint_interval: Interval for checkpointing. Defaults to 1.\n            Recommended to keep at 1 for single-node/in-memory backends.\n            For distributed engines like Apache Spark, larger values are recommended.\n        max_iter: Maximum number of Pregel iterations. Acts as a safeguard against\n            infinite iterations. Defaults to 20.\n\n    Returns:\n        A table with two columns:\n        - \"node_id\": The ID of each node in the graph\n        - \"distances\": A struct containing shortest distances to each landmark node\n            (distance_to_{landmark_id} -&gt; distance (int))\n\n    Warning:\n        Distances to landmarks are handled as columns internally. If landmarks contains\n        many elements, there may be performance issues due to operations on very wide tables.\n    \"\"\"\n    pregel = (\n        Pregel(graph)\n        .set_early_stopping(True)\n        .set_initial_active_flag(ibis._[IbisGraphConstants.ID.value].isin(landmarks))\n        .set_checkpoint_interval(checkpoint_interval)\n    )\n    distance_col_pattern = \"distance_to_{}\"\n\n    for lmark in landmarks:\n        col_name = distance_col_pattern.format(lmark)\n        pregel = pregel.add_vertex_col(\n            col_name,\n            ibis.ifelse(\n                ibis._[IbisGraphConstants.ID.value] == ibis.literal(lmark),\n                ibis.literal(0),\n                ibis.null(\"int\"),\n            ),\n            ibis.ifelse(\n                ibis.or_(\n                    pregel.pregel_msg()[col_name] &lt; ibis._[col_name],\n                    ibis.and_(pregel.pregel_msg()[col_name].notnull(), ibis._[col_name].isnull()),\n                ),\n                pregel.pregel_msg()[col_name],\n                ibis._[col_name],\n            ),\n        )\n\n    pregel_to_dst_check_exprs = [\n        ibis.or_(\n            pregel.pregel_src(distance_col_pattern.format(lmark)) + ibis.literal(1)\n            &lt; pregel.pregel_dst(distance_col_pattern.format(lmark)),\n            ibis.and_(\n                pregel.pregel_src(distance_col_pattern.format(lmark)).notnull(),\n                pregel.pregel_dst(distance_col_pattern.format(lmark)).isnull(),\n            ),\n        )\n        for lmark in landmarks\n    ]\n    pregel = pregel.add_message_to_dst(\n        ibis.ifelse(\n            ibis.or_(*pregel_to_dst_check_exprs),\n            ibis.struct(\n                {\n                    distance_col_pattern.format(lmark): pregel.pregel_src(\n                        distance_col_pattern.format(lmark)\n                    )\n                    + ibis.literal(1)\n                    for lmark in landmarks\n                }\n            ),\n            ibis.null(),\n        )\n    )\n\n    if not graph.is_directed:\n        pregel_to_src_check_exprs = [\n            ibis.or_(\n                pregel.pregel_dst(distance_col_pattern.format(lmark)) + ibis.literal(1)\n                &lt; pregel.pregel_src(distance_col_pattern.format(lmark)),\n                ibis.and_(\n                    pregel.pregel_dst(distance_col_pattern.format(lmark)).notnull(),\n                    pregel.pregel_src(distance_col_pattern.format(lmark)).isnull(),\n                ),\n            )\n            for lmark in landmarks\n        ]\n        pregel = pregel.add_message_to_src(\n            ibis.ifelse(\n                ibis.or_(*pregel_to_src_check_exprs),\n                ibis.struct(\n                    {\n                        distance_col_pattern.format(lmark): pregel.pregel_dst(\n                            distance_col_pattern.format(lmark)\n                        )\n                        + ibis.literal(1)\n                        for lmark in landmarks\n                    }\n                ),\n                ibis.null(),\n            )\n        )\n\n    pregel = pregel.set_agg_expression_func(\n        lambda msg: ibis.struct(\n            {\n                distance_col_pattern.format(lmark): msg[distance_col_pattern.format(lmark)]\n                .collect()\n                .mins()\n                for lmark in landmarks\n            }\n        )\n    )\n\n    raw_output = pregel.set_max_iter(20).set_filter_messages_from_non_active(True).run()\n    return raw_output.select(\n        raw_output[IbisGraphConstants.ID.value].name(SP_NODE_ID_COL_NAME),\n        ibis.struct(\n            {\n                distance_col_pattern.format(lmark): raw_output[distance_col_pattern.format(lmark)]\n                for lmark in landmarks\n            }\n        ).name(DISTANCE_COL_NAME),\n    )\n</code></pre>"}]}